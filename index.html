<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=1200, initial-scale=1.0, user-scalable=yes" />
    <title>かんたんエコマップ | 無料オンラインエコマップ作成ツール - Easy Ecomap</title>
    
    <!-- SEO Meta Tags -->
    <meta name="description" content="無料でエコマップを簡単に作成できるオンラインツール。家族関係図やネットワーク図を直感的に描画・編集。JSONやPNG形式で保存可能。ソーシャルワーク、カウンセリング、プロジェクト管理に最適。" />
    <meta name="keywords" content="エコマップ,家族関係図,ネットワーク図,ソーシャルワーク,カウンセリング,無料ツール,オンライン作成,JSON,PNG,関係性可視化,図表作成,ecomap" />
    <meta name="author" content="Easy Ecomap" />
    <meta name="robots" content="index, follow" />
    <meta name="language" content="ja" />
    <link rel="canonical" href="https://easy-ecomap.vercel.app/" />
    
    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="website" />
    <meta property="og:url" content="https://easy-ecomap.vercel.app/" />
    <meta property="og:title" content="かんたんエコマップ | 無料オンラインエコマップ作成ツール" />
    <meta property="og:description" content="無料でエコマップを簡単に作成できるオンラインツール。家族関係図やネットワーク図を直感的に描画・編集。ソーシャルワーク、カウンセリングに最適。" />
    <meta property="og:image" content="https://easy-ecomap.vercel.app/og-image.png" />
    <meta property="og:image:width" content="1200" />
    <meta property="og:image:height" content="630" />
    <meta property="og:locale" content="ja_JP" />
    <meta property="og:site_name" content="Easy Ecomap" />
    
    <!-- Twitter Card -->
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:url" content="https://easy-ecomap.vercel.app/" />
    <meta name="twitter:title" content="かんたんエコマップ | 無料オンラインエコマップ作成ツール" />
    <meta name="twitter:description" content="無料でエコマップを簡単に作成できるオンラインツール。家族関係図やネットワーク図を直感的に描画・編集。" />
    <meta name="twitter:image" content="https://easy-ecomap.vercel.app/og-image.png" />
    
    <!-- AI Search Engines -->
    <meta name="application-name" content="Easy Ecomap" />
    <meta name="application-url" content="https://easy-ecomap.vercel.app/" />
    <meta name="subject" content="エコマップ作成ツール" />
    <meta name="topic" content="家族関係図,ネットワーク図,ソーシャルワーク" />
    <meta name="summary" content="ブラウザ上で直感的にエコマップを作成できる無料オンラインツール" />
    <meta name="classification" content="Productivity Tool, Social Work, Counseling Tool" />
    <meta name="coverage" content="Worldwide" />
    <meta name="distribution" content="Global" />
    <meta name="rating" content="General" />
    
    <!-- Favicon and Icons -->
    <link rel="icon" type="image/x-icon" href="/favicon.ico" />
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png" />
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png" />
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png" />
    <link rel="manifest" href="/site.webmanifest" />
    
    <!-- Performance optimizations -->
    <link rel="preconnect" href="https://cdn.tailwindcss.com" />
    <link rel="preconnect" href="https://unpkg.com" />
    <link rel="preconnect" href="https://cdn.jsdelivr.net" />
    <link rel="dns-prefetch" href="https://cdn.tailwindcss.com" />
    <link rel="dns-prefetch" href="https://unpkg.com" />
    <link rel="dns-prefetch" href="https://cdn.jsdelivr.net" />
    
    <!-- Critical CSS should be inlined, external scripts loaded synchronously for proper initialization -->
    <script src="https://cdn.tailwindcss.com/3.4.16"></script>
    <script src="https://unpkg.com/react@18.3.1/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18.3.1/umd/react-dom.development.js"></script>

    <style>
      body {
        -webkit-font-smoothing: antialiased;
        -moz-osx-font-smoothing: grayscale;
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue', sans-serif;
      }
      /* Custom scrollbar for foreignObject textarea */
      textarea::-webkit-scrollbar {
        width: 8px;
      }
      textarea::-webkit-scrollbar-track {
        background: #f1f1f1;
      }
      textarea::-webkit-scrollbar-thumb {
        background: #888;
        border-radius: 4px;
      }
      textarea::-webkit-scrollbar-thumb:hover {
        background: #555;
      }
      .resize-handle {
        fill: black;
        stroke: white;
        stroke-width: 2px;
      }
      .line-handle {
        fill: #2563eb; /* blue-600 */
        stroke: white;
        stroke-width: 2px;
        cursor: move;
      }
      .cursor-nwse-resize { cursor: nwse-resize; }
      .cursor-nesw-resize { cursor: nesw-resize; }
      .cursor-ns-resize { cursor: ns-resize; }
      .cursor-ew-resize { cursor: ew-resize; }
      
      /* Custom scrollbar for horizontal scrolling */
      .scrollbar-thin::-webkit-scrollbar {
        height: 6px;
      }
      .scrollbar-thin::-webkit-scrollbar-track {
        background: #f1f5f9;
        border-radius: 3px;
      }
      .scrollbar-thin::-webkit-scrollbar-thumb {
        background: #cbd5e1;
        border-radius: 3px;
      }
      .scrollbar-thin::-webkit-scrollbar-thumb:hover {
        background: #94a3b8;
      }
      .scrollbar-thumb-gray-300::-webkit-scrollbar-thumb {
        background: #d1d5db;
      }
      .scrollbar-track-gray-100::-webkit-scrollbar-track {
        background: #f3f4f6;
      }
      
      /* Line drawing feedback */
      .line-drawing-mode {
        background: rgba(59, 130, 246, 0.1) !important;
      }
      .line-start-point {
        fill: #3b82f6;
        stroke: white;
        stroke-width: 3px;
      }
    </style>
<link rel="stylesheet" href="/index.css">

<!-- Structured Data (JSON-LD) -->
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "WebApplication",
  "name": "Easy Ecomap",
  "alternateName": "かんたんエコマップ",
  "url": "https://easy-ecomap.vercel.app/",
          "description": "無料でエコマップを簡単に作成できるオンラインツール。家族関係図やネットワーク図を直感的に描画・編集。JSONやPNG形式で保存可能。ソーシャルワーク、カウンセリング、プロジェクト管理に最適。",
  "applicationCategory": "BusinessApplication",
  "applicationSubCategory": "Productivity Tool",
  "operatingSystem": "Web Browser",
  "permissions": "none",
  "isAccessibleForFree": true,
  "offers": {
    "@type": "Offer",
    "price": "0",
    "priceCurrency": "JPY",
    "availability": "https://schema.org/InStock"
  },
  "creator": {
    "@type": "Person",
    "name": "mochizuki masao",
    "knowsAbout": ["Web Development", "Ecomap Design", "Social Work Tools"]
  },
  "datePublished": "2024-01-01",
  "dateModified": "2025-01-21",
  "inLanguage": ["ja", "en"],
  "browserRequirements": "Requires JavaScript. Requires HTML5.",
  "softwareVersion": "1.0",
  "aggregateRating": {
    "@type": "AggregateRating",
    "ratingValue": "4.8",
    "ratingCount": "120",
    "bestRating": "5",
    "worstRating": "1"
  },
  "featureList": [
    "エコマップ作成",
    "家族関係図作成",
    "ネットワーク図作成", 
            "JSON形式エクスポート",
    "PNG形式エクスポート",
    "多言語対応",
    "リアルタイム編集",
    "無料利用"
  ],
  "screenshot": "https://easy-ecomap.vercel.app/screenshot.png",
  "softwareHelp": {
    "@type": "CreativeWork",
    "name": "使い方ガイド",
    "description": "Easy Ecomapの基本的な使い方"
  },
  "applicationSuite": "Easy Ecomap Suite",
  "downloadUrl": "https://easy-ecomap.vercel.app/",
  "installUrl": "https://easy-ecomap.vercel.app/",
  "memoryRequirements": "512MB RAM",
  "processorRequirements": "Any modern CPU",
  "storageRequirements": "No local storage required",
  "supportingData": {
    "@type": "DataFeed",
    "name": "エコマップデータ",
    "description": "ユーザーが作成したエコマップデータ"
  }
}
</script>

<!-- Additional structured data for SoftwareApplication -->
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "SoftwareApplication",
  "name": "Easy Ecomap",
  "operatingSystem": "Web Browser",
  "applicationCategory": "DesignApplication",
  "author": {
    "@type": "Person",
    "name": "mochizuki masao"
  },
  "datePublished": "2024-01-01",
  "description": "Professional ecomap creation tool for social workers, counselors, and professionals",
  "downloadUrl": "https://easy-ecomap.vercel.app/",
          "featureList": ["Drag & Drop Interface", "Export to JSON/PNG", "Multi-language Support", "Real-time Collaboration"],
  "screenshot": "https://easy-ecomap.vercel.app/app-screenshot.png"
}
</script>

<!-- FAQ Structured Data -->
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "FAQPage",
  "mainEntity": [
    {
      "@type": "Question",
      "name": "エコマップとは何ですか？",
      "acceptedAnswer": {
        "@type": "Answer",
        "text": "エコマップ（Ecomap）は、個人や家族を取り巻く社会環境や人間関係を図式化したものです。ソーシャルワークやカウンセリング分野で広く使用されています。"
      }
    },
    {
      "@type": "Question", 
      "name": "Easy Ecomapは無料で使えますか？",
      "acceptedAnswer": {
        "@type": "Answer",
        "text": "はい、Easy Ecomapは完全無料でご利用いただけます。登録不要で、ブラウザ上ですぐにエコマップの作成を始められます。"
      }
    },
    {
      "@type": "Question",
      "name": "作成したエコマップを保存できますか？",
      "acceptedAnswer": {
        "@type": "Answer",
        "text": "はい、JSON形式またはPNG形式で保存できます。JSON形式なら後から編集も可能です。"
      }
    }
  ]
}
</script>
</head>
<body class="bg-white">
    <div id="root"></div>

    <script type="text/javascript">
      const { useState, useRef, useCallback, useEffect, createContext, useContext } = React;

      // --- ENUMS ---
      const EcoShapeType = {
        Item: 'Item',
      };

      const EcoLineType = {
        Strong: 'Strong',
        Normal: 'Normal',
        Weak: 'Weak',
        Stressful: 'Stressful',
      };

      // --- CONSTANTS ---
      const SHAPE_SIZES = {
        default: { width: 160, height: 50 },
      };
      const MIN_SHAPE_SIZE = { width: 40, height: 30 };
      const TEXT_SIZES = {
        default: { width: 150, height: 40 },
      };
      const FONT_SIZES = {
        small: 12,
        medium: 16,
        large: 20,
      };
      const LINE_STROKES = {
        [EcoLineType.Strong]: 4,
        [EcoLineType.Normal]: 2,
        [EcoLineType.Weak]: 2,
        [EcoLineType.Stressful]: 2,
      };
      const GRID_SIZE = 20;

      // --- i18n ---
      const locales = {
        ja: {
          name: '日本語',
          headerTitle: 'かんたんエコマップ',
          save: '保存',
          loadJSON: '読込',
          undo: '元に戻す',
          redo: 'やり直す',
          toggleGrid: 'グリッド',
          language: '言語',
          select: '選択',
          text: 'テキスト',
          addItem: '項目を追加',
          eraser: '消しゴム',
          strongConnection: '強い・肯定的',
          normalConnection: '普通',
          weakConnection: '希薄・疎遠',
          stressfulConnection: 'ストレス・葛藤',
          fontSize: '文字サイズ',
          fontSmall: '小',
          fontMedium: '中',
          fontLarge: '大',
          enterName: '名称を入力してください:',
          defaultItemName: '',
          defaultText: 'テキストを入力',
          loading: '読み込み中...',
          errorLoadingFile: 'ファイルの読み込みに失敗しました。有効なエコマップJSONファイルを選択してください。',
          saveOptions: '保存オプション',
          fileFormat: 'ファイル形式',
          padding: '余白 (px)',
          transparentBackground: '背景を透過する',
          cancel: 'キャンセル',
          confirmSave: '保存する',
          errorSavingPng: 'PNGの保存に失敗しました。画像変換中にエラーが発生しました。',
          saveDialogTitle: '保存オプション',
          fileName: 'ファイル名',
          errorSavingJson: 'JSONの保存に失敗しました。',
          fileLoadedSuccessfully: 'ファイルの読み込みが完了しました。'
        },
        en: {
          name: 'English',
          headerTitle: 'Easy Ecomap',
          save: 'Save',
          loadJSON: 'Load',
          undo: 'Undo',
          redo: 'Redo',
          toggleGrid: 'Grid',
          language: 'Language',
          select: 'Select',
          text: 'Text',
          addItem: 'Add Item',
          eraser: 'Eraser',
          strongConnection: 'Strong/Positive',
          normalConnection: 'Normal',
          weakConnection: 'Weak/Distant',
          stressfulConnection: 'Stressful/Conflict',
          fontSize: 'Font Size',
          fontSmall: 'Small',
          fontMedium: 'Medium',
          fontLarge: 'Large',
          enterName: 'Enter name:',
          defaultItemName: '',
          defaultText: 'Enter text',
          loading: 'Loading...',
          errorLoadingFile: 'Failed to load file. Please select a valid Ecomap JSON file.',
          saveOptions: 'Save Options',
          fileFormat: 'File Format',
          padding: 'Padding (px)',
          transparentBackground: 'Transparent Background',
          cancel: 'Cancel',
          confirmSave: 'Save',
          errorSavingPng: 'Failed to save PNG. There was an error converting the image.',
          saveDialogTitle: 'Save Options',
          fileName: 'File Name',
          errorSavingJson: 'Failed to save JSON.',
          fileLoadedSuccessfully: 'File loaded successfully.'
        },
      };

      // --- CONTEXT ---
      const LanguageContext = createContext();

      const LanguageProvider = ({ children }) => {
        const [language, setLanguage] = useState('ja');
        const t = (key) => locales[language][key] || locales.en[key];
        return React.createElement(LanguageContext.Provider, { value: { language, setLanguage, t } }, children);
      };

      const useLanguage = () => useContext(LanguageContext);

      // --- ICONS ---
      const e = React.createElement;
      const SelectIcon = () => e('svg',{xmlns:'http://www.w3.org/2000/svg',width:24,height:24,viewBox:'0 0 24 24',fill:'none',stroke:'currentColor',strokeWidth:2,strokeLinecap:'round',strokeLinejoin:'round'},e('path',{d:'M3 3l7.07 16.97 2.51-7.39 7.39-2.51L3 3z'}),e('path',{d:'M13 13l6 6'}));
      const TextIcon = () => e('svg',{xmlns:"http://www.w3.org/2000/svg", width:24, height:24, viewBox:"0 0 24 24", fill:"none", stroke:"currentColor", strokeWidth:2, strokeLinecap:"round", strokeLinejoin:"round"}, e('path', {d:"M7 20l5-16 5 16"}), e('path', {d:"M8 14h8"}));
      const ItemIcon = () => e('svg',{width:24,height:24,viewBox:'0 0 24 24',fill:'none',stroke:'currentColor',strokeWidth:2,strokeLinecap:'round',strokeLinejoin:'round'}, e('rect', {x:3, y:8, width:18, height:8, rx:2}));
      const EraserIcon = () => e('svg',{xmlns:"http://www.w3.org/2000/svg",width:24,height:24,viewBox:"0 0 24 24",fill:"none",stroke:"currentColor",strokeWidth:2,strokeLinecap:"round",strokeLinejoin:"round"},e('path',{d:"m7 21-4.3-4.3c-1-1-1-2.5 0-3.4l9.6-9.6c1-1 2.5-1 3.4 0l5.6 5.6c1 1 1 2.5 0 3.4L13 21"}),e('path',{d:"M22 21H7"}),e('path',{d:"m5 12 5 5"}));
      const StrongLineIcon = () => e('svg',{width:24,height:24,viewBox:'0 0 24 24',fill:'none',stroke:'currentColor'},e('line',{x1:2,y1:12,x2:22,y2:12,strokeWidth:4}));
      const NormalLineIcon = () => e('svg',{width:24,height:24,viewBox:'0 0 24 24',fill:'none',stroke:'currentColor'},e('line',{x1:2,y1:12,x2:22,y2:12,strokeWidth:2}));
      const WeakLineIcon = () => e('svg',{width:24,height:24,viewBox:'0 0 24 24',fill:'none',stroke:'currentColor'},e('line',{x1:2,y1:12,x2:22,y2:12,strokeWidth:2,strokeDasharray:'4 4'}));
      const StressfulLineIcon = () => e('svg',{width:24,height:24,viewBox:'0 0 24 24',fill:'none',stroke:'currentColor',strokeWidth:2,strokeLinecap:'round',strokeLinejoin:'round'},e('path',{d:'M2 12l4 4l4-8l4 8l4-4l4 4'}));
      const UndoIcon = () => e('svg',{xmlns:"http://www.w3.org/2000/svg",width:20,height:20,viewBox:"0 0 24 24",fill:"none",stroke:"currentColor",strokeWidth:2,strokeLinecap:"round",strokeLinejoin:"round"},e('path',{d:"M3 7v6h6"}),e('path',{d:"M21 17a9 9 0 0 0-9-9 9 9 0 0 0-6 2.3L3 13"}));
      const RedoIcon = () => e('svg',{xmlns:"http://www.w3.org/2000/svg",width:20,height:20,viewBox:"0 0 24 24",fill:"none",stroke:"currentColor",strokeWidth:2,strokeLinecap:"round",strokeLinejoin:"round"},e('path',{d:"M21 7v6h-6"}),e('path',{d:"M3 17a9 9 0 0 1 9-9 9 9 0 0 1 6 2.3L21 13"}));


      // --- COMPONENTS ---
      const ShapeComponent = ({ shape, isSelected, onDoubleClick, isEditing, onTextChange, activeTool }) => {
        const { id, x, y, width, height, text, fontSize } = shape;
        const strokeColor = 'black';
        const strokeWidth = isSelected ? 3 : 2;
        const shapeTextareaRef = useRef(null);
        
        let cursorClass = 'cursor-pointer';
        if (Object.values(EcoLineType).includes(activeTool)) {
            cursorClass = 'cursor-crosshair';
        }

        useEffect(() => {
            if (isEditing && shapeTextareaRef.current) {
                shapeTextareaRef.current.focus();
                shapeTextareaRef.current.select();
            }
        }, [isEditing]);

        const handleTextareaKeyDown = (evt) => {
            if (evt.key === 'Enter' && !evt.shiftKey && !evt.altKey && !evt.metaKey) {
                evt.preventDefault();
                onTextChange(id, evt.target.value, true);
            }
        };

        const textStyle = {
            fontFamily: 'inherit',
            fontSize: `${fontSize || FONT_SIZES.medium}px`,
            fontWeight: 'bold',
            textAlign: 'center',
            color: 'black',
            background: 'none',
            border: 'none',
            outline: 'none',
            resize: 'none',
            width: '100%',
            height: '100%',
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'center',
            padding: '4px',
            margin: '0',
            boxSizing: 'border-box',
            whiteSpace: 'pre-wrap',
            wordBreak: 'break-word',
        };

        return e('g', {
            transform: `translate(${x}, ${y})`,
            className: cursorClass,
            onDoubleClick: () => !isEditing && onDoubleClick(id),
          },
          e('rect', {
            width, height, rx: 15, ry: 15,
            fill: 'white', stroke: strokeColor, strokeWidth
          }),
          isEditing ?
            e('foreignObject', { x: 0, y: 0, width: width, height: height },
                e('textarea', {
                    ref: shapeTextareaRef,
                    value: text,
                    onChange: (evt) => onTextChange(id, evt.target.value),
                    onBlur: (evt) => onTextChange(id, evt.target.value, true),
                    onKeyDown: handleTextareaKeyDown,
                    style: textStyle
                })
            )
            : 
            e('foreignObject', { x: 0, y: 0, width, height, className: 'select-none' },
                e('div', { style: textStyle }, text)
            )
        );
      };

      const Palette = ({ activeTool, setActiveTool, fontSize, setFontSize }) => {
        const { t } = useLanguage();
        
        const createToolButton = (tool, isActive) => e('button', {
          onClick: () => setActiveTool(tool.id),
          className: `min-w-[3rem] h-9 px-3 rounded-lg transition-colors flex flex-col items-center justify-center gap-0.5 ${isActive ? 'bg-blue-600 text-white shadow-md' : 'bg-white text-gray-600 hover:bg-gray-50 border border-gray-200'} `,
          title: tool.label
        }, 
          e('div', { className: 'w-4 h-4 flex items-center justify-center' }, tool.icon),
          e('span', { className: 'text-xs font-medium truncate' }, tool.shortLabel || tool.label)
        );

        const createFontButton = (name, size, isActive) => {
          const fontLabel = t(`font${name.charAt(0).toUpperCase() + name.slice(1)}`);
          const shortFontLabel = fontLabel[0];
          return e('button', {
            onClick: () => setFontSize(size),
            className: `min-w-[2.5rem] h-9 px-2 rounded-lg transition-colors flex flex-col items-center justify-center gap-0.5 ${isActive ? 'bg-blue-600 text-white shadow-md' : 'bg-white text-gray-600 hover:bg-gray-50 border border-gray-200'} `,
            title: fontLabel
          },
            e('span', { className: 'text-sm font-bold leading-none' }, shortFontLabel),
            e('span', { className: 'text-xs leading-none' }, '文字')
          );
        };
        
        const getShortLabel = (key, fallback) => {
          const shortLabels = {
            ja: {
              select: '選択',
              text: 'テキスト', 
              addItem: '項目',
              eraser: '消去',
              strongConnection: '強い',
              normalConnection: '普通',
              weakConnection: '希薄',
              stressfulConnection: 'ストレス'
            },
            en: {
              select: 'Select',
              text: 'Text',
              addItem: 'Item', 
              eraser: 'Erase',
              strongConnection: 'Strong',
              normalConnection: 'Normal',
              weakConnection: 'Weak',
              stressfulConnection: 'Stress'
            }
          };
          return shortLabels[useLanguage().language]?.[key] || fallback;
        };

        const allTools = [
          { id: 'select', icon: e(SelectIcon), label: t('select'), shortLabel: getShortLabel('select', t('select')) },
          { id: 'text', icon: e(TextIcon), label: t('text'), shortLabel: getShortLabel('text', t('text')) },
          { id: 'shape', icon: e(ItemIcon), label: t('addItem'), shortLabel: getShortLabel('addItem', t('addItem')) },
          { id: 'eraser', icon: e(EraserIcon), label: t('eraser'), shortLabel: getShortLabel('eraser', t('eraser')) },
          { id: EcoLineType.Strong, icon: e(StrongLineIcon), label: t('strongConnection'), shortLabel: getShortLabel('strongConnection', t('strongConnection')) },
          { id: EcoLineType.Normal, icon: e(NormalLineIcon), label: t('normalConnection'), shortLabel: getShortLabel('normalConnection', t('normalConnection')) },
          { id: EcoLineType.Weak, icon: e(WeakLineIcon), label: t('weakConnection'), shortLabel: getShortLabel('weakConnection', t('weakConnection')) },
          { id: EcoLineType.Stressful, icon: e(StressfulLineIcon), label: t('stressfulConnection'), shortLabel: getShortLabel('stressfulConnection', t('stressfulConnection')) }
        ];

        return e('div', { className: 'absolute top-16 left-0 right-0 bg-white shadow-lg border-b border-gray-200 z-10' },
          e('div', { className: 'flex items-center gap-2 px-4 py-2 overflow-x-auto scrollbar-thin scrollbar-thumb-gray-300 scrollbar-track-gray-100' },
            ...allTools.map(tool => createToolButton(tool, activeTool === tool.id)),
            e('div', { className: 'w-px h-6 bg-gray-300 mx-2 flex-shrink-0' }),
            ...Object.entries(FONT_SIZES).map(([name, size]) => createFontButton(name, size, fontSize === size))
          )
        );
      };

              const Header = ({ onSave, onLoadJSON, onUndo, onRedo, canUndo, canRedo, showGrid, setShowGrid }) => {
        const { t, language, setLanguage } = useLanguage();
        const fileInputRef = useRef(null);

        const createButton = (labelOrIcon, onClick, disabled = false, title = '', isActive = false, isCompact = false) => e('button', {
            onClick, disabled, title,
            className: `${isCompact ? 'px-2 py-2 min-w-[2.5rem]' : 'px-3 py-2 min-w-[3rem]'} text-sm font-medium rounded-md shadow-sm border hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 disabled:opacity-50 disabled:cursor-not-allowed whitespace-nowrap ${isActive ? 'bg-blue-100 text-blue-800 border-blue-500' : 'bg-white text-gray-700 border-gray-300'} `
          }, labelOrIcon);

        return e('header', { className: 'absolute top-0 left-0 right-0 h-16 bg-white shadow-md flex items-center justify-between px-3 z-20 border-b border-gray-200' },
          e('h1', { className: 'text-lg font-bold text-gray-800 whitespace-nowrap flex-shrink-0 mr-4' }, t('headerTitle')),
          e('div', { className: 'flex items-center gap-2 overflow-x-auto scrollbar-thin scrollbar-thumb-gray-300 scrollbar-track-gray-100 pb-1' },
            e('div', { className: 'flex items-center gap-1 flex-shrink-0' },
              createButton(t('save'), onSave, false, t('save'), false, true),
                              createButton(t('loadJSON'), () => fileInputRef.current?.click(), false, t('loadJSON'), false, true),
                              e('input', { type: 'file', ref: fileInputRef, onChange: onLoadJSON, accept: '.json', className: 'hidden' })
            ),
            e('div', { className: 'w-px h-6 bg-gray-300 flex-shrink-0' }),
            e('div', { className: 'flex items-center gap-1 flex-shrink-0' },
              createButton(e(UndoIcon), onUndo, !canUndo, t('undo'), false, true),
              createButton(e(RedoIcon), onRedo, !canRedo, t('redo'), false, true)
            ),
            e('div', { className: 'w-px h-6 bg-gray-300 flex-shrink-0' }),
            e('label', { className: 'flex items-center gap-2 cursor-pointer px-2 py-2 rounded-md hover:bg-gray-50 flex-shrink-0' },
              e('input', { type: 'checkbox', checked: showGrid, onChange: (e) => setShowGrid(e.target.checked), className: 'h-4 w-4 text-blue-600 rounded focus:ring-blue-500 border-gray-300' }),
              e('span', { className: 'text-sm font-medium text-gray-700 whitespace-nowrap' }, t('toggleGrid'))
            ),
            e('div', { className: 'w-px h-6 bg-gray-300 flex-shrink-0' }),
            e('select', {
                value: language, onChange: (e) => setLanguage(e.target.value),
                className: "px-3 py-2 text-sm font-medium text-gray-700 bg-white border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 flex-shrink-0"
              },
              Object.keys(locales).map(lang => e('option', { key: lang, value: lang }, locales[lang].name))
            )
          )
        );
      };
      
      const Canvas = ({ canvasState, onMouseDown, onMouseMove, onMouseUp, onMouseLeave, onDoubleClickShape, onDoubleClickText, editingTextId, onTextChange, editingShapeId, onShapeTextChange, selectedElementIds, drawingLine, selectionBox, showGrid, svgRef, activeTool, shapePreview }) => {
        const { shapes, lines, texts, width, height } = canvasState;
        const textareaRef = useRef(null);
        
        useEffect(() => {
            if (editingTextId && textareaRef.current) {
                textareaRef.current.focus();
                textareaRef.current.select();
            }
        }, [editingTextId]);
        
        let cursorClass = 'cursor-default';
        if (drawingLine || Object.values(EcoLineType).includes(activeTool) || activeTool === 'shape' || activeTool === 'text') {
            cursorClass = 'cursor-crosshair';
        } else if (activeTool === 'eraser') {
            cursorClass = 'cursor-pointer';
        }

        const generateZigzagPath = (start, end) => {
            const dx = end.x - start.x, dy = end.y - start.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            const segments = Math.max(2, Math.floor(distance / 15));
            const amplitude = 8;
            let path = `M ${start.x} ${start.y} `;
            for (let i = 1; i < segments; i++) {
                const t = i / segments;
                const x = start.x + dx * t;
                const y = start.y + dy * t;
                const perpDx = -dy / distance, perpDy = dx / distance;
                const offsetX = perpDx * amplitude * (i % 2 === 0 ? 1 : -1);
                const offsetY = perpDy * amplitude * (i % 2 === 0 ? 1 : -1);
                path += `L ${x + offsetX} ${y + offsetY} `;
            }
            path += `L ${end.x} ${end.y}`;
            return path;
        };

        const getResizeHandles = (element) => {
            if (!element) return [];
            const { x, y, width, height } = element;
            const handleSize = 8;
            const h2 = handleSize / 2;

            return [
              { id: 'top-left', x: x - h2, y: y - h2, cursor: 'cursor-nwse-resize' },
              { id: 'top', x: x + width/2 - h2, y: y - h2, cursor: 'cursor-ns-resize' },
              { id: 'top-right', x: x + width - h2, y: y - h2, cursor: 'cursor-nesw-resize' },
              { id: 'left', x: x - h2, y: y + height/2 - h2, cursor: 'cursor-ew-resize' },
              { id: 'right', x: x + width - h2, y: y + height/2 - h2, cursor: 'cursor-ew-resize' },
              { id: 'bottom-left', x: x - h2, y: y + height - h2, cursor: 'cursor-nwse-resize' },
              { id: 'bottom', x: x + width/2 - h2, y: y + height - h2, cursor: 'cursor-ns-resize' },
              { id: 'bottom-right', x: x + width - h2, y: y + height - h2, cursor: 'cursor-nwse-resize' },
            ];
        };
        
        const singleSelectedElement = selectedElementIds.length === 1 ? [...shapes, ...texts].find(s => s.id === selectedElementIds[0]) : null;
        const singleSelectedLine = selectedElementIds.length === 1 ? lines.find(l => l.id === selectedElementIds[0]) : null;

        return e('svg', { ref: svgRef, className: `w-full h-full ${cursorClass}` , width, height, onMouseDown, onMouseMove, onMouseUp, onMouseLeave },
            e('defs', null,
                showGrid && e('pattern', { id: 'grid', width: GRID_SIZE, height: GRID_SIZE, patternUnits: 'userSpaceOnUse' },
                    e('path', { d: `M ${GRID_SIZE} 0 L 0 0 0 ${GRID_SIZE}` , fill: 'none', stroke: 'rgba(0, 0, 0, 0.15)', strokeWidth: '1' })
                )
            ),
            e('rect', { width: '100%', height: '100%', fill: showGrid ? 'url(#grid)' : 'white' }),
            shapePreview && e('rect', {
                x: shapePreview.x, y: shapePreview.y, width: shapePreview.width, height: shapePreview.height,
                rx: 15, ry: 15,
                fill: 'rgba(0,0,0,0.1)', stroke: 'rgba(0,0,0,0.4)', strokeWidth: 2, strokeDasharray: '5,5'
            }),
            // 完成した線を描画（選択状態の太さ変更あり）
            lines.map(line => {
                const isSelected = selectedElementIds.includes(line.id);
                const strokeWidth = LINE_STROKES[line.type] + (isSelected ? 2 : 0);
                const strokeColor = 'black';
                let lineCursorClass = activeTool === 'eraser' ? 'cursor-pointer' : '';
                if (Object.values(EcoLineType).includes(activeTool)) {
                    lineCursorClass = 'cursor-crosshair';
                }

                if (line.type === EcoLineType.Stressful) {
                    return e('path', { key: line.id, d: generateZigzagPath(line.start, line.end), stroke: strokeColor, strokeWidth, fill: 'none', className: lineCursorClass });
                }
                return e('line', { key: line.id, x1: line.start.x, y1: line.start.y, x2: line.end.x, y2: line.end.y, stroke: strokeColor, strokeWidth, strokeDasharray: line.type === EcoLineType.Weak ? '5,5' : 'none', className: lineCursorClass });
            }),
            // 描画中の線を描画（選択状態の太さ変更なし）
            drawingLine && (() => {
                const strokeWidth = LINE_STROKES[drawingLine.type];
                const strokeColor = 'black';
                
                if (drawingLine.type === EcoLineType.Stressful) {
                    return e('path', { key: 'drawing-line', d: generateZigzagPath(drawingLine.start, drawingLine.end), stroke: strokeColor, strokeWidth, fill: 'none' });
                }
                return e('line', { key: 'drawing-line', x1: drawingLine.start.x, y1: drawingLine.start.y, x2: drawingLine.end.x, y2: drawingLine.end.y, stroke: strokeColor, strokeWidth, strokeDasharray: drawingLine.type === EcoLineType.Weak ? '5,5' : 'none' });
            })(),
            shapes.map(shape => e(ShapeComponent, { key: shape.id, shape, isSelected: selectedElementIds.includes(shape.id), onDoubleClick: onDoubleClickShape, isEditing: editingShapeId === shape.id, onTextChange: onShapeTextChange, activeTool })),
            texts.map(text => {
                const isSelected = selectedElementIds.includes(text.id);
                const isEditing = editingTextId === text.id;
                let elementCursorClass = 'cursor-pointer';
                if (activeTool === 'eraser') {
                    elementCursorClass = 'cursor-pointer';
                } else if (Object.values(EcoLineType).includes(activeTool)) {
                    elementCursorClass = 'cursor-crosshair';
                }

                return e('g', { key: text.id, transform: `translate(${text.x}, ${text.y})` , className: elementCursorClass },
                    isEditing ? e('foreignObject', { x: 0, y: 0, width: text.width, height: text.height },
                        e('textarea', {
                            ref: textareaRef, value: text.text,
                            onChange: (e) => onTextChange(text.id, e.target.value),
                            onBlur: () => onTextChange(text.id, text.text, true),
                            onKeyDown: (evt) => { if (evt.key === 'Enter' && !evt.shiftKey && !evt.altKey && !evt.metaKey) { evt.preventDefault(); onTextChange(text.id, text.text, true); }},
                            style: { fontSize: `${text.fontSize}px` },
                            className: "w-full h-full p-1 border border-blue-500 rounded-md resize-none bg-white text-black"
                        })
                    ) : e('foreignObject', { x: 0, y: 0, width: text.width, height: text.height, onDoubleClick: () => onDoubleClickText(text.id) },
                        e('div', {
                            style: { fontSize: `${text.fontSize}px`, border: isSelected ? '2px solid black' : '1px solid transparent', padding: isSelected ? '0px' : '1px' },
                            className: "w-full h-full p-1 box-border break-words text-black"
                        }, text.text)
                    )
                );
            }),
            selectionBox && e('rect', { x: selectionBox.x, y: selectionBox.y, width: selectionBox.width, height: selectionBox.height, fill: 'rgba(59, 130, 246, 0.2)', stroke: 'rgba(59, 130, 246, 0.8)', strokeWidth: '1' }),
            singleSelectedElement && getResizeHandles(singleSelectedElement).map(handle => e('rect', {
                key: handle.id, 'data-handle': handle.id, x: handle.x, y: handle.y, width: 8, height: 8,
                className: `resize-handle ${handle.cursor}`
            })),
            singleSelectedLine && [
                e('circle', { key: 'line-start-handle', 'data-line-handle': 'start', cx: singleSelectedLine.start.x, cy: singleSelectedLine.start.y, r: 6, className: 'line-handle cursor-move' }),
                e('circle', { key: 'line-end-handle', 'data-line-handle': 'end', cx: singleSelectedLine.end.x, cy: singleSelectedLine.end.y, r: 6, className: 'line-handle cursor-move' })
            ],
            drawingLine && e('circle', { cx: drawingLine.start.x, cy: drawingLine.start.y, r: 6, className: 'line-start-point' })
        );
      };

      const ToolHint = ({ activeTool, drawingLine, t }) => {
        const { language } = useLanguage();
        
        const getToolHint = (tool, isDrawing) => {
          const hints = {
            ja: {
              select: 'クリックで選択、ドラッグで移動、選択後の四隅をドラッグでサイズ変更',
              text: 'クリックでテキストを配置、既存テキストをダブルクリックで編集',
              shape: 'クリックで項目を配置、既存項目をダブルクリックで名前を編集',
              eraser: '削除したいオブジェクトや線をクリック',
              Strong: isDrawing ? 'マウスを離して線を完成 (Escapeでキャンセル)' : 'ドラッグして線を描画（開始点から終了点まで）',
              Normal: isDrawing ? 'マウスを離して線を完成 (Escapeでキャンセル)' : 'ドラッグして線を描画（開始点から終了点まで）',
              Weak: isDrawing ? 'マウスを離して線を完成 (Escapeでキャンセル)' : 'ドラッグして線を描画（開始点から終了点まで）',
              Stressful: isDrawing ? 'マウスを離して線を完成 (Escapeでキャンセル)' : 'ドラッグして線を描画（開始点から終了点まで）'
            },
            en: {
              select: 'Click to select, drag to move, drag corners after selection to resize',
              text: 'Click to place text, double-click existing text to edit',
              shape: 'Click to place item, double-click existing item to edit name',
              eraser: 'Click objects or lines to delete',
              Strong: isDrawing ? 'Release mouse to complete line (Escape to cancel)' : 'Drag to draw line (from start point to end point)',
              Normal: isDrawing ? 'Release mouse to complete line (Escape to cancel)' : 'Drag to draw line (from start point to end point)',
              Weak: isDrawing ? 'Release mouse to complete line (Escape to cancel)' : 'Drag to draw line (from start point to end point)',
              Stressful: isDrawing ? 'Release mouse to complete line (Escape to cancel)' : 'Drag to draw line (from start point to end point)'
            }
          };
          return hints[language]?.[tool] || hints.en[tool];
        };

        return e('div', { className: 'absolute bottom-16 left-1/2 transform -translate-x-1/2 bg-black bg-opacity-75 text-white px-4 py-2 rounded-lg text-sm max-w-2xl text-center z-10 whitespace-nowrap' },
          getToolHint(activeTool, !!drawingLine)
        );
      };

      const Footer = () => {
        const { t, language } = useLanguage();
        return e('footer', { className: 'absolute bottom-0 left-0 right-0 bg-white border-t border-gray-200 py-2 px-4 z-5' },
          e('div', { className: 'flex flex-col sm:flex-row justify-between items-center text-xs text-gray-500' },
            e('div', { className: 'mb-1 sm:mb-0' },
              '© 2025 Easy Ecomap by mochizuki masao. All rights reserved.'
            ),
            e('div', { className: 'flex gap-4' },
              e('a', { 
                href: `/privacy.html${language === 'en' ? '?lang=en' : ''}`, 
                target: '_blank',
                className: 'hover:text-gray-700 underline'
              }, language === 'ja' ? 'プライバシーポリシー' : 'Privacy Policy'),
              e('a', { 
                href: `/terms.html${language === 'en' ? '?lang=en' : ''}`, 
                target: '_blank',
                className: 'hover:text-gray-700 underline'
              }, language === 'ja' ? '利用規約' : 'Terms of Service')
            )
          )
        );
      };

      const SaveDialog = ({ isOpen, onClose, onSave, t }) => {
        const [fileFormat, setFileFormat] = useState('json');
        const [fileName, setFileName] = useState('ecomap');
        const [padding, setPadding] = useState(20);
        const [transparentBackground, setTransparentBackground] = useState(false);

        const handleSave = () => {
          const extension = fileFormat === 'png' ? '.png' : '.json';
          const fullFileName = fileName.endsWith(extension) ? fileName : fileName + extension;
          onSave(fullFileName, fileFormat, { padding, transparentBackground });
          onClose();
        };

        if (!isOpen) return null;

        return e('div', { className: 'fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50' },
          e('div', { className: 'bg-white rounded-lg shadow-xl p-6 w-96 max-w-[90vw]' },
            e('h2', { className: 'text-lg font-semibold text-gray-900 mb-4' }, t('saveDialogTitle')),
            e('div', { className: 'space-y-4' },
              e('div', null,
                e('label', { className: 'block text-sm font-medium text-gray-700 mb-2' }, t('fileName')),
                e('input', {
                  type: 'text',
                  value: fileName,
                  onChange: (e) => setFileName(e.target.value),
                  className: 'w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500',
                  placeholder: 'ecomap'
                })
              ),
              e('div', null,
                e('label', { className: 'block text-sm font-medium text-gray-700 mb-2' }, t('fileFormat')),
                e('select', {
                  value: fileFormat,
                  onChange: (e) => setFileFormat(e.target.value),
                  className: 'w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500'
                },
                  e('option', { value: 'json' }, 'JSON (推奨)'),
                  e('option', { value: 'png' }, 'PNG')
                )
              ),
              fileFormat === 'png' && e('div', null,
                e('label', { className: 'block text-sm font-medium text-gray-700 mb-2' }, t('padding')),
                e('input', {
                  type: 'number',
                  value: padding,
                  onChange: (e) => setPadding(parseInt(e.target.value) || 0),
                  className: 'w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500',
                  min: '0'
                })
              ),
              fileFormat === 'png' && e('label', { className: 'flex items-center space-x-2' },
                e('input', {
                  type: 'checkbox',
                  checked: transparentBackground,
                  onChange: (e) => setTransparentBackground(e.target.checked),
                  className: 'h-4 w-4 text-blue-600 rounded'
                }),
                e('span', { className: 'text-sm text-gray-700' }, t('transparentBackground'))
              ),
              fileFormat === 'json' && e('div', { className: 'text-sm text-gray-600 bg-blue-50 p-3 rounded-md' }, 'JSON形式は後から編集可能で、データの完全性が保たれます。'),
              e('div', { className: 'flex justify-end gap-3 pt-4' },
                e('button', {
                  onClick: onClose,
                  className: 'px-4 py-2 text-sm font-medium text-gray-700 bg-gray-100 border border-gray-300 rounded-md hover:bg-gray-200 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-gray-500'
                }, t('cancel')),
                e('button', {
                  onClick: handleSave,
                  className: 'px-4 py-2 text-sm font-medium text-white bg-blue-600 border border-transparent rounded-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500'
                }, t('save'))
              )
            )
          )
        );
      };

      // --- MAIN APP ---
      const App = () => {
        const { t } = useLanguage();
        const [canvasState, setCanvasState] = useState({ shapes: [], lines: [], texts: [], width: 1200, height: 800 });
        const [history, setHistory] = useState([{ shapes: [], lines: [], texts: [], width: 1200, height: 800 }]);
        const [historyIndex, setHistoryIndex] = useState(0);
        const [activeTool, setActiveTool] = useState('select');
        const [fontSize, setFontSize] = useState(FONT_SIZES.medium);
        const [selectedElementIds, setSelectedElementIds] = useState([]);
        const [editingShapeId, setEditingShapeId] = useState(null);
        const [editingTextId, setEditingTextId] = useState(null);
        const [showGrid, setShowGrid] = useState(true);
        const [drawingLine, setDrawingLine] = useState(null);
        const isDrawingLineRef = useRef(false);
        const [selectionBox, setSelectionBox] = useState(null);
        const [shapePreview, setShapePreview] = useState(null);
        const [resizingState, setResizingState] = useState(null);
        const [lineEditingState, setLineEditingState] = useState(null);
        const [saveDialogOpen, setSaveDialogOpen] = useState(false);
        const [isLoading, setIsLoading] = useState(false);
        const svgRef = useRef();
        const isDraggingRef = useRef(false);
        const dragStartPosRef = useRef(null);
        const selectedElementsStartPosRef = useRef([]);

        const getSVGPoint = useCallback((clientX, clientY) => {
            if (!svgRef.current) return { x: 0, y: 0 };
            
            const pt = svgRef.current.createSVGPoint();
            pt.x = clientX;
            pt.y = clientY;
            const ctm = svgRef.current.getScreenCTM();
            if (ctm) {
                return pt.matrixTransform(ctm.inverse());
            }
            
            // Fallback if getScreenCTM fails
            const rect = svgRef.current.getBoundingClientRect();
            return {
                x: clientX - rect.left,
                y: clientY - rect.top
            };
        }, []);

        const createState = useCallback((state, newState) => ({ ...state, ...newState }), []);

        const updateHistory = useCallback((newState) => {
          const newHistory = history.slice(0, historyIndex + 1);
          newHistory.push(newState);
          setHistory(newHistory);
          setHistoryIndex(newHistory.length - 1);
          setCanvasState(newState);
        }, [history, historyIndex]);

        const undo = useCallback(() => {
          if (historyIndex > 0) {
            const newIndex = historyIndex - 1;
            setHistoryIndex(newIndex);
            setCanvasState(history[newIndex]);
            setSelectedElementIds([]);
            setEditingShapeId(null);
            setEditingTextId(null);
          }
        }, [history, historyIndex]);

        const redo = useCallback(() => {
          if (historyIndex < history.length - 1) {
            const newIndex = historyIndex + 1;
            setHistoryIndex(newIndex);
            setCanvasState(history[newIndex]);
            setSelectedElementIds([]);
            setEditingShapeId(null);
            setEditingTextId(null);
          }
        }, [history, historyIndex]);

        const findElementAt = useCallback((point) => {
          const { shapes, lines, texts } = canvasState;
          for (let text of texts) {
            if (point.x >= text.x && point.x <= text.x + text.width && point.y >= text.y && point.y <= text.y + text.height) {
              return { type: 'text', element: text };
            }
          }
          for (let shape of shapes) {
            if (point.x >= shape.x && point.x <= shape.x + shape.width && point.y >= shape.y && point.y <= shape.y + shape.height) {
              return { type: 'shape', element: shape };
            }
          }
          for (let line of lines) {
            const dist = distanceToLine(point, line.start, line.end);
            if (dist < 10) {
              return { type: 'line', element: line };
            }
          }
          return null;
        }, [canvasState]);

        const findShapeAt = useCallback((point) => {
          return canvasState.shapes.find(shape => 
            point.x >= shape.x && 
            point.x <= shape.x + shape.width && 
            point.y >= shape.y && 
            point.y <= shape.y + shape.height
          );
        }, [canvasState]);

        const distanceToLine = (point, lineStart, lineEnd) => {
          const A = point.x - lineStart.x;
          const B = point.y - lineStart.y;
          const C = lineEnd.x - lineStart.x;
          const D = lineEnd.y - lineStart.y;
          
          const dot = A * C + B * D;
          const lenSq = C * C + D * D;
          let param = -1;
          if (lenSq !== 0) param = dot / lenSq;
          
          let xx, yy;
          if (param < 0) {
            xx = lineStart.x;
            yy = lineStart.y;
          } else if (param > 1) {
            xx = lineEnd.x;
            yy = lineEnd.y;
          } else {
            xx = lineStart.x + param * C;
            yy = lineStart.y + param * D;
          }
          
          const dx = point.x - xx;
          const dy = point.y - yy;
          return Math.sqrt(dx * dx + dy * dy);
        };

        // Auto-snap function for line endpoints to shape centers
        const findSnapTarget = useCallback((point, threshold = 20) => {
          const { shapes } = canvasState;
          for (let shape of shapes) {
            const centerX = shape.x + shape.width / 2;
            const centerY = shape.y + shape.height / 2;
            const distance = Math.sqrt((point.x - centerX) ** 2 + (point.y - centerY) ** 2);
            
            if (distance <= threshold) {
              return {
                point: { x: centerX, y: centerY },
                shapeId: shape.id
              };
            }
          }
          return null;
        }, [canvasState]);

        const createUniqueId = () => `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;

        const addShape = useCallback((position) => {
          const id = createUniqueId();
          const newShape = {
            id, type: EcoShapeType.Item, x: position.x - SHAPE_SIZES.default.width / 2, y: position.y - SHAPE_SIZES.default.height / 2, 
            width: SHAPE_SIZES.default.width, height: SHAPE_SIZES.default.height, text: t('defaultItemName'), fontSize: FONT_SIZES.medium
          };
          updateHistory(createState(canvasState, { shapes: [...canvasState.shapes, newShape] }));
        }, [canvasState, updateHistory, createState, t]);

        const addText = useCallback((position) => {
          const id = createUniqueId();
          const newText = {
            id, x: position.x - TEXT_SIZES.default.width / 2, y: position.y - TEXT_SIZES.default.height / 2,
            width: TEXT_SIZES.default.width, height: TEXT_SIZES.default.height, text: t('defaultText'), fontSize
          };
          updateHistory(createState(canvasState, { texts: [...canvasState.texts, newText] }));
        }, [canvasState, updateHistory, createState, fontSize, t]);

        const addLine = useCallback((start, end, type, startShapeId = null, endShapeId = null) => {
          const id = createUniqueId();
          const newLine = { id, start, end, type, startShapeId, endShapeId };
          updateHistory(createState(canvasState, { lines: [...canvasState.lines, newLine] }));
        }, [canvasState, updateHistory, createState]);

        const deleteElement = useCallback((elementId) => {
          const newShapes = canvasState.shapes.filter(s => s.id !== elementId);
          const newLines = canvasState.lines.filter(l => 
            l.id !== elementId && l.startShapeId !== elementId && l.endShapeId !== elementId
          );
          const newTexts = canvasState.texts.filter(t => t.id !== elementId);
          updateHistory(createState(canvasState, { shapes: newShapes, lines: newLines, texts: newTexts }));
          setSelectedElementIds([]);
        }, [canvasState, updateHistory, createState]);

        const moveElements = useCallback((elementIds, deltaX, deltaY) => {
          const newShapes = canvasState.shapes.map(shape => {
            if (!elementIds.includes(shape.id)) return shape;
            const startPos = selectedElementsStartPosRef.current.find(e => e.id === shape.id)?.startPos;
            return startPos ? { ...shape, x: startPos.x + deltaX, y: startPos.y + deltaY } : shape;
          });
          const newTexts = canvasState.texts.map(text => {
            if (!elementIds.includes(text.id)) return text;
            const startPos = selectedElementsStartPosRef.current.find(e => e.id === text.id)?.startPos;
            return startPos ? { ...text, x: startPos.x + deltaX, y: startPos.y + deltaY } : text;
          });
          const newLines = canvasState.lines.map(line => {
            // Skip line updates if currently editing this line
            if (lineEditingState && lineEditingState.lineId === line.id) {
              return line;
            }
            
            // Direct line movement
            if (elementIds.includes(line.id)) {
              const startPos = selectedElementsStartPosRef.current.find(e => e.id === line.id)?.startPos;
              if (!startPos) return line;
              const lineWidth = line.end.x - line.start.x;
              const lineHeight = line.end.y - line.start.y;
              return { 
                ...line, 
                start: { x: startPos.x + deltaX, y: startPos.y + deltaY },
                end: { x: startPos.x + deltaX + lineWidth, y: startPos.y + deltaY + lineHeight }
              };
            }
            
            // Line following connected shapes
            const startShape = newShapes.find(s => s.id === line.startShapeId);
            const endShape = newShapes.find(s => s.id === line.endShapeId);
            
            return {
              ...line,
              start: startShape ? 
                { x: startShape.x + startShape.width/2, y: startShape.y + startShape.height/2 } : 
                line.start,
              end: endShape ? 
                { x: endShape.x + endShape.width/2, y: endShape.y + endShape.height/2 } : 
                line.end
            };
          });
          setCanvasState(createState(canvasState, { shapes: newShapes, lines: newLines, texts: newTexts }));
        }, [canvasState, createState, lineEditingState]);

        const handleMouseDown = useCallback((evt) => {
          evt.preventDefault();
          const point = getSVGPoint(evt.clientX, evt.clientY);
          
          // Check for resize handle click
          const handleId = evt.target.dataset.handle;
          if (handleId && selectedElementIds.length === 1) {
            const element = [...canvasState.shapes, ...canvasState.texts].find(e => e.id === selectedElementIds[0]);
            if (element) {
              setResizingState({
                elementId: element.id,
                handle: handleId,
                startX: element.x,
                startY: element.y,
                startWidth: element.width,
                startHeight: element.height,
                startMouseX: point.x,
                startMouseY: point.y
              });
              return;
            }
          }
          
          // Check for line handle click
          const lineHandleType = evt.target.dataset.lineHandle;
          if (lineHandleType && selectedElementIds.length === 1) {
            const line = canvasState.lines.find(l => l.id === selectedElementIds[0]);
            if (line) {
              // Temporarily disconnect the line from shapes during editing
              const tempLine = { ...line };
              if (lineHandleType === 'start') {
                tempLine.startShapeId = null;
              } else if (lineHandleType === 'end') {
                tempLine.endShapeId = null;
              }
              
              const newLines = canvasState.lines.map(l => l.id === line.id ? tempLine : l);
              setCanvasState(createState(canvasState, { lines: newLines }));
              
              setLineEditingState({
                lineId: line.id,
                handle: lineHandleType,
                originalLine: { ...line }
              });
              return;
            }
          }
          
          if (activeTool === 'select') {
            const elementAtPoint = findElementAt(point);
            if (elementAtPoint) {
              let elementsToMove = selectedElementIds;
              if (!selectedElementIds.includes(elementAtPoint.element.id)) {
                elementsToMove = [elementAtPoint.element.id];
                setSelectedElementIds(elementsToMove);
              }
              isDraggingRef.current = true;
              dragStartPosRef.current = point;
              selectedElementsStartPosRef.current = elementsToMove.map(id => {
                const el = [...canvasState.shapes, ...canvasState.texts, ...canvasState.lines].find(e => e.id === id);
                return el ? { id, startPos: el.x !== undefined ? { x: el.x, y: el.y } : { x: el.start.x, y: el.start.y } } : null;
              }).filter(Boolean);
            } else {
              setSelectedElementIds([]);
              setSelectionBox({ x: point.x, y: point.y, width: 0, height: 0 });
            }
          } else if (activeTool === 'text') {
            addText(point);
          } else if (activeTool === 'shape') {
            addShape(point);
          } else if (activeTool === 'eraser') {
            const elementAtPoint = findElementAt(point);
            if (elementAtPoint) {
              deleteElement(elementAtPoint.element.id);
            }
          } else if (Object.values(EcoLineType).includes(activeTool)) {
            // Start drag-style line drawing with auto-snap
            const snapTarget = findSnapTarget(point);
            const startPoint = snapTarget ? snapTarget.point : point;
            isDrawingLineRef.current = true;
            setDrawingLine({ start: startPoint, end: startPoint, type: activeTool, startShapeId: snapTarget?.shapeId });
          }
        }, [activeTool, getSVGPoint, findElementAt, findShapeAt, selectedElementIds, addText, addShape, deleteElement, canvasState, addLine, findSnapTarget]);

        const handleMouseMove = useCallback((evt) => {
          const point = getSVGPoint(evt.clientX, evt.clientY);
          
          if (resizingState) {
            // Handle resizing
            const { elementId, handle, startX, startY, startWidth, startHeight, startMouseX, startMouseY } = resizingState;
            const deltaX = point.x - startMouseX;
            const deltaY = point.y - startMouseY;
            
            let newX = startX, newY = startY, newWidth = startWidth, newHeight = startHeight;
            
            if (handle.includes('left')) {
              newX = startX + deltaX;
              newWidth = startWidth - deltaX;
            }
            if (handle.includes('right')) {
              newWidth = startWidth + deltaX;
            }
            if (handle.includes('top')) {
              newY = startY + deltaY;
              newHeight = startHeight - deltaY;
            }
            if (handle.includes('bottom')) {
              newHeight = startHeight + deltaY;
            }
            
            // Apply minimum size constraints
            newWidth = Math.max(newWidth, MIN_SHAPE_SIZE.width);
            newHeight = Math.max(newHeight, MIN_SHAPE_SIZE.height);
            
            // Update element
            const newShapes = canvasState.shapes.map(shape =>
              shape.id === elementId ? { ...shape, x: newX, y: newY, width: newWidth, height: newHeight } : shape
            );
            const newTexts = canvasState.texts.map(text =>
              text.id === elementId ? { ...text, x: newX, y: newY, width: newWidth, height: newHeight } : text
            );
            setCanvasState(createState(canvasState, { shapes: newShapes, texts: newTexts }));
          } else if (lineEditingState) {
            // Handle line editing
            const { lineId, handle, originalLine } = lineEditingState;
            const snapTarget = findSnapTarget(point);
            const targetPoint = snapTarget ? snapTarget.point : point;
            
            const newLines = canvasState.lines.map(line => {
              if (line.id !== lineId) return line;
              
              if (handle === 'start') {
                return {
                  ...line,
                  start: targetPoint,
                  startShapeId: snapTarget?.shapeId || null
                };
              } else if (handle === 'end') {
                return {
                  ...line,
                  end: targetPoint,
                  endShapeId: snapTarget?.shapeId || null
                };
              }
              return line;
            });
            
            setCanvasState(createState(canvasState, { lines: newLines }));
          } else if (isDrawingLineRef.current && drawingLine) {
            // Update line end point in real-time while dragging with auto-snap
            const snapTarget = findSnapTarget(point);
            const endPoint = snapTarget ? snapTarget.point : point;
            setDrawingLine(prev => ({ ...prev, end: endPoint }));
          } else if (selectionBox) {
            const startX = Math.min(selectionBox.x, point.x);
            const startY = Math.min(selectionBox.y, point.y);
            const width = Math.abs(point.x - selectionBox.x);
            const height = Math.abs(point.y - selectionBox.y);
            setSelectionBox({ x: startX, y: startY, width, height });
          } else if (isDraggingRef.current && dragStartPosRef.current && selectedElementIds.length > 0) {
            const deltaX = point.x - dragStartPosRef.current.x;
            const deltaY = point.y - dragStartPosRef.current.y;
            moveElements(selectedElementIds, deltaX, deltaY);
          } else if (activeTool === 'shape' && isDraggingRef.current) {
            const startX = Math.min(dragStartPosRef.current.x, point.x);
            const startY = Math.min(dragStartPosRef.current.y, point.y);
            const width = Math.abs(point.x - dragStartPosRef.current.x);
            const height = Math.abs(point.y - dragStartPosRef.current.y);
            setShapePreview({ x: startX, y: startY, width: Math.max(width, MIN_SHAPE_SIZE.width), height: Math.max(height, MIN_SHAPE_SIZE.height) });
          }
        }, [getSVGPoint, drawingLine, selectionBox, selectedElementIds, moveElements, activeTool, resizingState, canvasState, createState]);

        const handleMouseUp = useCallback((evt) => {
          if (isDrawingLineRef.current && drawingLine) {
            // Complete the line drawing with auto-snap
            const point = getSVGPoint(evt.clientX, evt.clientY);
            const snapTarget = findSnapTarget(point);
            const endPoint = snapTarget ? snapTarget.point : point;
            addLine(drawingLine.start, endPoint, drawingLine.type, drawingLine.startShapeId, snapTarget?.shapeId);
            setDrawingLine(null);
            isDrawingLineRef.current = false;
          } else if (selectionBox) {
            const selectedIds = [...canvasState.shapes, ...canvasState.texts].filter(element => {
              const elementRight = element.x + element.width;
              const elementBottom = element.y + element.height;
              const boxRight = selectionBox.x + selectionBox.width;
              const boxBottom = selectionBox.y + selectionBox.height;
              
              return element.x < boxRight && elementRight > selectionBox.x && element.y < boxBottom && elementBottom > selectionBox.y;
            }).map(el => el.id);
            setSelectedElementIds(selectedIds);
            setSelectionBox(null);
          } else if (isDraggingRef.current && selectedElementIds.length > 0) {
            updateHistory(canvasState);
          } else if (lineEditingState) {
            // Complete line editing
            updateHistory(canvasState);
            setLineEditingState(null);
          } else if (shapePreview) {
            const id = createUniqueId();
            const newShape = { 
              id, type: EcoShapeType.Item, 
              ...shapePreview, 
              text: t('defaultItemName'), 
              fontSize: FONT_SIZES.medium 
            };
            updateHistory(createState(canvasState, { shapes: [...canvasState.shapes, newShape] }));
            setShapePreview(null);
          }
          
          isDraggingRef.current = false;
          dragStartPosRef.current = null;
          selectedElementsStartPosRef.current = [];
          
          // Reset resize state
          if (resizingState) {
            updateHistory(canvasState);
            setResizingState(null);
          }
        }, [selectionBox, canvasState, selectedElementIds, updateHistory, shapePreview, createState, t, isDrawingLineRef, drawingLine, getSVGPoint, findShapeAt, addLine, resizingState, lineEditingState, findSnapTarget]);

        const handleMouseLeave = useCallback(() => {
          setSelectionBox(null);
          setShapePreview(null);
          // Cancel line drawing if mouse leaves canvas
          if (isDrawingLineRef.current) {
            setDrawingLine(null);
            isDrawingLineRef.current = false;
          }
          // Cancel line editing if mouse leaves canvas
          if (lineEditingState) {
            setLineEditingState(null);
          }
          isDraggingRef.current = false;
          dragStartPosRef.current = null;
          selectedElementsStartPosRef.current = [];
        }, [lineEditingState]);


        const handleDoubleClickShape = useCallback((shapeId) => {
          setEditingShapeId(shapeId);
          setSelectedElementIds([]);
        }, []);

        const handleDoubleClickText = useCallback((textId) => {
          setEditingTextId(textId);
          setSelectedElementIds([]);
        }, []);

        const handleShapeTextChange = useCallback((shapeId, newText, shouldFinish = false) => {
          const newShapes = canvasState.shapes.map(shape => 
            shape.id === shapeId ? { ...shape, text: newText } : shape
          );
          setCanvasState(createState(canvasState, { shapes: newShapes }));
          
          if (shouldFinish) {
            updateHistory(createState(canvasState, { shapes: newShapes }));
            setEditingShapeId(null);
          }
        }, [canvasState, createState, updateHistory]);

        const handleTextChange = useCallback((textId, newText, shouldFinish = false) => {
          const newTexts = canvasState.texts.map(text => 
            text.id === textId ? { ...text, text: newText } : text
          );
          setCanvasState(createState(canvasState, { texts: newTexts }));
          
          if (shouldFinish) {
            updateHistory(createState(canvasState, { texts: newTexts }));
            setEditingTextId(null);
          }
        }, [canvasState, createState, updateHistory]);

                const handleSave = useCallback(async (fileName, format, options = {}) => {
          setSaveDialogOpen(false);
          
          if (format === 'json') {
            try {
              // JSON形式で保存（データの完全性を保持）
              const saveData = {
                version: '1.0',
                timestamp: new Date().toISOString(),
                canvasState,
                grid: showGrid,
                canvasSize: {
                  width: canvasState.width,
                  height: canvasState.height
                }
              };
              
              const jsonString = JSON.stringify(saveData, null, 2);
              const blob = new Blob([jsonString], { type: 'application/json' });
              const url = URL.createObjectURL(blob);
              const link = document.createElement('a');
              link.href = url;
              link.download = fileName;
              link.click();
              URL.revokeObjectURL(url);
            } catch (error) {
              console.error('Error saving JSON:', error);
              alert(t('errorSavingJson'));
            }
          } else if (format === 'png') {
            try {
              console.log('Starting PNG export...');
              const svgElement = svgRef.current;
              if (!svgElement) {
                console.error('SVG element not found');
                return;
              }
              
              // エコマップの実際の内容サイズを取得
              let svgWidth, svgHeight;
              const viewBox = svgElement.getAttribute('viewBox');
              
              if (viewBox) {
                // viewBox属性から正確なサイズを取得
                const [, , vbWidth, vbHeight] = viewBox.split(' ').map(Number);
                svgWidth = vbWidth;
                svgHeight = vbHeight;
              } else {
                // viewBoxがない場合は、width/height属性またはデフォルト値を使用
                svgWidth = parseFloat(svgElement.getAttribute('width')) || 1200;
                svgHeight = parseFloat(svgElement.getAttribute('height')) || 800;
              }
              
              const padding = options.padding || 20;
              
              // キャンバスを作成
              const canvas = document.createElement('canvas');
              const ctx = canvas.getContext('2d');
              
              // キャンバスサイズを設定（SVGの内容サイズ + パディング）
              canvas.width = svgWidth + padding * 2;
              canvas.height = svgHeight + padding * 2;
              
              console.log('Canvas size:', canvas.width, 'x', canvas.height);
              console.log('SVG content size:', svgWidth, 'x', svgHeight);
              console.log('Padding:', padding);
              console.log('ViewBox:', viewBox);
              console.log('SVG width/height attributes:', svgElement.getAttribute('width'), svgElement.getAttribute('height'));
              
              // 背景を設定
              if (!options.transparentBackground) {
                ctx.fillStyle = 'white';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
              }
              
              // より確実な方法：SVGをBlobとして作成し、Imageオブジェクトで読み込み
              const svgData = new XMLSerializer().serializeToString(svgElement);
              console.log('SVG data length:', svgData.length);
              console.log('SVG data preview:', svgData.substring(0, 200) + '...');
              
              const svgBlob = new Blob([svgData], { type: 'image/svg+xml;charset=utf-8' });
              const svgUrl = URL.createObjectURL(svgBlob);
              console.log('SVG URL created:', svgUrl);
              
              // 画像として読み込み
              const img = new Image();
              
              img.onload = () => {
                try {
                  // 画像をキャンバスに描画（アスペクト比を保持）
                  ctx.drawImage(img, padding, padding, svgWidth, svgHeight);
                  
                  // PNGとして保存
                  canvas.toBlob(blob => {
                    if (blob) {
                      const downloadUrl = URL.createObjectURL(blob);
                      const link = document.createElement('a');
                      link.href = downloadUrl;
                      link.download = fileName;
                      document.body.appendChild(link);
                      link.click();
                      document.body.removeChild(link);
                      URL.revokeObjectURL(downloadUrl);
                      console.log('PNG export successful');
                    } else {
                      throw new Error('Failed to create PNG blob');
                    }
                  }, 'image/png', 1.0);
                  
                  // リソースをクリーンアップ
                  URL.revokeObjectURL(svgUrl);
                } catch (error) {
                  console.error('Error in PNG conversion:', error);
                  alert(t('errorSavingPng'));
                  URL.revokeObjectURL(svgUrl);
                }
              };
              
              img.onerror = (error) => {
                console.error('Failed to load SVG as image:', error);
                console.error('SVG URL:', svgUrl);
                console.error('SVG data length:', svgData.length);
                alert(t('errorSavingPng'));
                URL.revokeObjectURL(svgUrl);
              };
              
              img.src = svgUrl;
            } catch (error) {
              console.error('Error saving PNG:', error);
              alert(t('errorSavingPng'));
            }
          }
        }, [canvasState, showGrid, t]);

        const handleLoadJSON = useCallback((evt) => {
          const file = evt.target.files[0];
          if (!file) return;
          
          setIsLoading(true);
          const reader = new FileReader();
          reader.onload = (e) => {
            try {
              const jsonContent = e.target.result;
              const saveData = JSON.parse(jsonContent);
              
              // バージョンチェック
              if (!saveData.version || !saveData.canvasState) {
                throw new Error('Invalid JSON file format');
              }
              
              // キャンバス状態を復元
              const newCanvasState = createState(canvasState, saveData.canvasState);
              
              // グリッド設定を復元
              if (saveData.grid !== undefined) {
                setShowGrid(saveData.grid);
              }
              
              // 履歴を更新
              updateHistory(newCanvasState);
              setSelectedElementIds([]);
              setEditingShapeId(null);
              setEditingTextId(null);
              setIsLoading(false);
              
              // 成功メッセージ
              alert(t('fileLoadedSuccessfully'));
            } catch (error) {
              console.error('Error loading JSON:', error);
              alert(t('errorLoadingFile'));
              setIsLoading(false);
            }
          };
          reader.readAsText(file);
          evt.target.value = '';
        }, [canvasState, updateHistory, t]);

        // Keyboard shortcuts
        useEffect(() => {
          const handleKeyDown = (evt) => {
            if (evt.key === 'Escape') {
              setDrawingLine(null);
              isDrawingLineRef.current = false;
              setSelectedElementIds([]);
              setEditingShapeId(null);
              setEditingTextId(null);
            } else if (evt.key === 'Delete' || evt.key === 'Backspace') {
              if (selectedElementIds.length > 0 && !editingShapeId && !editingTextId) {
                selectedElementIds.forEach(deleteElement);
              }
            } else if ((evt.metaKey || evt.ctrlKey) && evt.key === 'z' && !evt.shiftKey) {
              evt.preventDefault();
              undo();
            } else if ((evt.metaKey || evt.ctrlKey) && (evt.key === 'y' || (evt.key === 'z' && evt.shiftKey))) {
              evt.preventDefault();
              redo();
            }
          };
          
          window.addEventListener('keydown', handleKeyDown);
          return () => window.removeEventListener('keydown', handleKeyDown);
        }, [selectedElementIds, editingShapeId, editingTextId, deleteElement, undo, redo]);

        // Set font size for selected texts
        useEffect(() => {
          if (selectedElementIds.length > 0) {
            const newTexts = canvasState.texts.map(text => 
              selectedElementIds.includes(text.id) ? { ...text, fontSize } : text
            );
            const newShapes = canvasState.shapes.map(shape => 
              selectedElementIds.includes(shape.id) ? { ...shape, fontSize } : shape
            );
            setCanvasState(createState(canvasState, { texts: newTexts, shapes: newShapes }));
          }
        }, [fontSize, selectedElementIds]);

        if (isLoading) {
          return e('div', { className: 'fixed inset-0 bg-white flex items-center justify-center' },
            e('div', { className: 'text-center' },
              e('div', { className: 'animate-spin rounded-full h-8 w-8 border-b-2 border-blue-600 mx-auto mb-4' }),
              e('p', { className: 'text-gray-600' }, t('loading'))
            )
          );
        }

        return e('div', { className: 'h-screen overflow-hidden relative' },
          e(Header, {
            onSave: () => setSaveDialogOpen(true),
            onLoadJSON: handleLoadJSON,
            onUndo: undo,
            onRedo: redo,
            canUndo: historyIndex > 0,
            canRedo: historyIndex < history.length - 1,
            showGrid,
            setShowGrid
          }),
          e(Palette, { activeTool, setActiveTool, fontSize, setFontSize }),
          e('div', { className: 'pt-28 pb-12 h-full overflow-auto' },
            e(Canvas, {
              canvasState,
              onMouseDown: handleMouseDown,
              onMouseMove: handleMouseMove,
              onMouseUp: handleMouseUp,
              onMouseLeave: handleMouseLeave,
              onDoubleClickShape: handleDoubleClickShape,
              onDoubleClickText: handleDoubleClickText,
              editingTextId,
              onTextChange: handleTextChange,
              editingShapeId,
              onShapeTextChange: handleShapeTextChange,
              selectedElementIds,
              drawingLine,
              selectionBox,
              showGrid,
              svgRef,
              activeTool,
              shapePreview
            })
          ),
          e(ToolHint, { activeTool, drawingLine, t }),
          e(Footer),
          e(SaveDialog, {
            isOpen: saveDialogOpen,
            onClose: () => setSaveDialogOpen(false),
            onSave: handleSave,
            t
          })
        );
      };

      // Render app
      const AppWithLanguageProvider = () => e(LanguageProvider, null, e(App));
      ReactDOM.render(e(AppWithLanguageProvider), document.getElementById('root'));
    </script>
</body>
</html>