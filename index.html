<!DOCTYPE html>
<html lang="ja">

  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=1200, initial-scale=1.0, user-scalable=yes" />
    <title>かんたんエコマップ | 無料オンラインエコマップ作成ツール - Easy Ecomap JP</title>

    <!-- SEO Meta Tags -->
    <meta name="description"
      content="無料でエコマップを簡単に作成できるオンラインツール。家族関係図やネットワーク図を直感的に描画・編集。JSONやPNG形式で保存可能。ソーシャルワーク、カウンセリング、プロジェクト管理に最適。" />
    <meta name="keywords" content="エコマップ,家族関係図,ネットワーク図,ソーシャルワーク,カウンセリング,無料ツール,オンライン作成,JSON,PNG,関係性可視化,図表作成,ecomap" />
    <meta name="author" content="Easy Ecomap JP" />
    <meta name="robots" content="index, follow" />
    <meta name="language" content="ja" />
    <link rel="canonical" href="https://easy-ecomap.vercel.app/" />

    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="website" />
    <meta property="og:url" content="https://easy-ecomap.vercel.app/" />
    <meta property="og:title" content="かんたんエコマップ | 無料オンラインエコマップ作成ツール" />
    <meta property="og:description" content="無料でエコマップを簡単に作成できるオンラインツール。家族関係図やネットワーク図を直感的に描画・編集。ソーシャルワーク、カウンセリングに最適。" />
    <meta property="og:image" content="https://easy-ecomap.vercel.app/og-image.png" />
    <meta property="og:image:width" content="1200" />
    <meta property="og:image:height" content="630" />
    <meta property="og:locale" content="ja_JP" />
    <meta property="og:site_name" content="Easy Ecomap JP" />

    <!-- Twitter Card -->
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:url" content="https://easy-ecomap.vercel.app/" />
    <meta name="twitter:title" content="かんたんエコマップ | 無料オンラインエコマップ作成ツール" />
    <meta name="twitter:description" content="無料でエコマップを簡単に作成できるオンラインツール。家族関係図やネットワーク図を直感的に描画・編集。" />
    <meta name="twitter:image" content="https://easy-ecomap.vercel.app/og-image.png" />

    <!-- AI Search Engines -->
    <meta name="application-name" content="Easy Ecomap JP" />
    <meta name="application-url" content="https://easy-ecomap.vercel.app/" />
    <meta name="subject" content="エコマップ作成ツール" />
    <meta name="topic" content="家族関係図,ネットワーク図,ソーシャルワーク" />
    <meta name="summary" content="ブラウザ上で直感的にエコマップを作成できる無料オンラインツール" />
    <meta name="classification" content="Productivity Tool, Social Work, Counseling Tool" />
    <meta name="coverage" content="Worldwide" />
    <meta name="distribution" content="Global" />
    <meta name="rating" content="General" />

    <!-- Favicon and Icons -->
    <link rel="icon" type="image/x-icon" href="/favicon.ico" />
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png" />
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png" />
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png" />
    <link rel="manifest" href="/site.webmanifest" />

    <!-- Performance optimizations -->
    <link rel="preconnect" href="https://cdn.tailwindcss.com" />
    <link rel="preconnect" href="https://unpkg.com" />
    <link rel="preconnect" href="https://cdn.jsdelivr.net" />
    <link rel="dns-prefetch" href="https://cdn.tailwindcss.com" />
    <link rel="dns-prefetch" href="https://unpkg.com" />
    <link rel="dns-prefetch" href="https://cdn.jsdelivr.net" />

    <!-- Critical CSS should be inlined, external scripts loaded synchronously for proper initialization -->
    <script src="https://cdn.tailwindcss.com/3.4.16"></script>
    <script src="https://unpkg.com/react@18.3.1/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18.3.1/umd/react-dom.development.js"></script>

    <style>
      body {
        -webkit-font-smoothing: antialiased;
        -moz-osx-font-smoothing: grayscale;
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue', sans-serif;
      }

      /* Custom scrollbar for foreignObject textarea */
      textarea::-webkit-scrollbar {
        width: 8px;
      }

      textarea::-webkit-scrollbar-track {
        background: #f1f1f1;
      }

      textarea::-webkit-scrollbar-thumb {
        background: #888;
        border-radius: 4px;
      }

      textarea::-webkit-scrollbar-thumb:hover {
        background: #555;
      }

      .resize-handle {
        fill: black;
        stroke: white;
        stroke-width: 2px;
      }

      .line-handle {
        fill: #2563eb;
        /* blue-600 */
        stroke: white;
        stroke-width: 2px;
        cursor: move;
      }

      .cursor-nwse-resize {
        cursor: nwse-resize;
      }

      .cursor-nesw-resize {
        cursor: nesw-resize;
      }

      .cursor-ns-resize {
        cursor: ns-resize;
      }

      .cursor-ew-resize {
        cursor: ew-resize;
      }

      /* Custom scrollbar for horizontal scrolling */
      .scrollbar-thin::-webkit-scrollbar {
        height: 6px;
      }

      .scrollbar-thin::-webkit-scrollbar-track {
        background: #f1f5f9;
        border-radius: 3px;
      }

      .scrollbar-thin::-webkit-scrollbar-thumb {
        background: #cbd5e1;
        border-radius: 3px;
      }

      .scrollbar-thin::-webkit-scrollbar-thumb:hover {
        background: #94a3b8;
      }

      .scrollbar-thumb-gray-300::-webkit-scrollbar-thumb {
        background: #d1d5db;
      }

      .scrollbar-track-gray-100::-webkit-scrollbar-track {
        background: #f3f4f6;
      }

      /* Line drawing feedback */
      .line-drawing-mode {
        background: rgba(59, 130, 246, 0.1) !important;
      }

      .line-start-point {
        fill: #3b82f6;
        stroke: white;
        stroke-width: 3px;
      }
    </style>
    <link rel="stylesheet" href="/index.css">

    <!-- Structured Data (JSON-LD) -->
    <script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "WebApplication",
  "name": "Easy Ecomap JP",
  "alternateName": "かんたんエコマップ",
  "url": "https://easy-ecomap.vercel.app/",
          "description": "無料でエコマップを簡単に作成できるオンラインツール。家族関係図やネットワーク図を直感的に描画・編集。JSONやPNG形式で保存可能。ソーシャルワーク、カウンセリング、プロジェクト管理に最適。",
  "applicationCategory": "BusinessApplication",
  "applicationSubCategory": "Productivity Tool",
  "operatingSystem": "Web Browser",
  "permissions": "none",
  "isAccessibleForFree": true,
  "offers": {
    "@type": "Offer",
    "price": "0",
    "priceCurrency": "JPY",
    "availability": "https://schema.org/InStock"
  },
  "creator": {
    "@type": "Person",
    "name": "soi24.com",
    "knowsAbout": ["Web Development", "Ecomap Design", "Social Work Tools"]
  },
  "datePublished": "2024-01-01",
  "dateModified": "2025-01-21",
  "inLanguage": ["ja", "en"],
  "browserRequirements": "Requires JavaScript. Requires HTML5.",
  "softwareVersion": "1.0",
  "aggregateRating": {
    "@type": "AggregateRating",
    "ratingValue": "4.8",
    "ratingCount": "120",
    "bestRating": "5",
    "worstRating": "1"
  },
  "featureList": [
    "エコマップ作成",
    "家族関係図作成",
    "ネットワーク図作成",
            "JSON形式エクスポート",
    "PNG形式エクスポート",
    "多言語対応",
    "リアルタイム編集",
    "無料利用"
  ],
  "screenshot": "https://easy-ecomap.vercel.app/screenshot.png",
  "softwareHelp": {
    "@type": "CreativeWork",
    "name": "使い方ガイド",
    "description": "Easy Ecomap JPの基本的な使い方"
  },
  "applicationSuite": "Easy Ecomap JP Suite",
  "downloadUrl": "https://easy-ecomap.vercel.app/",
  "installUrl": "https://easy-ecomap.vercel.app/",
  "memoryRequirements": "512MB RAM",
  "processorRequirements": "Any modern CPU",
  "storageRequirements": "No local storage required",
  "supportingData": {
    "@type": "DataFeed",
    "name": "エコマップデータ",
    "description": "ユーザーが作成したエコマップデータ"
  }
}
</script>

    <!-- Additional structured data for SoftwareApplication -->
    <script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "SoftwareApplication",
  "name": "Easy Ecomap JP",
  "operatingSystem": "Web Browser",
  "applicationCategory": "DesignApplication",
  "author": {
    "@type": "Person",
    "name": "soi24.com"
  },
  "datePublished": "2024-01-01",
  "description": "Professional ecomap creation tool for social workers, counselors, and professionals",
  "downloadUrl": "https://easy-ecomap.vercel.app/",
          "featureList": ["Drag & Drop Interface", "Export to JSON/PNG", "Multi-language Support", "Real-time Collaboration"],
  "screenshot": "https://easy-ecomap.vercel.app/app-screenshot.png"
}
</script>

    <!-- FAQ Structured Data -->
    <script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "FAQPage",
  "mainEntity": [
    {
      "@type": "Question",
      "name": "エコマップとは何ですか？",
      "acceptedAnswer": {
        "@type": "Answer",
        "text": "エコマップ（Ecomap）は、個人や家族を取り巻く社会環境や人間関係を図式化したものです。ソーシャルワークやカウンセリング分野で広く使用されています。"
      }
    },
    {
      "@type": "Question",
      "name": "Easy Ecomap JPは無料で使えますか？",
      "acceptedAnswer": {
        "@type": "Answer",
        "text": "はい、Easy Ecomap JPは完全無料でご利用いただけます。登録不要で、ブラウザ上ですぐにエコマップの作成を始められます。"
      }
    },
    {
      "@type": "Question",
      "name": "作成したエコマップを保存できますか？",
      "acceptedAnswer": {
        "@type": "Answer",
        "text": "はい、JSON形式またはPNG形式で保存できます。JSON形式なら後から編集も可能です。"
      }
    }
  ]
}
</script>
  </head>

  <body class="bg-white">
    <div id="root"></div>

    <script type="text/javascript">
      const { useState, useRef, useCallback, useEffect, createContext, useContext } = React;

      // --- ENUMS ---
      const EcoShapeType = {
        Item: 'Item',
      };

      const EcoLineType = {
        Strong: 'Strong',
        Normal: 'Normal',
        Weak: 'Weak',
        Stressful: 'Stressful',
      };

      // --- CONSTANTS ---
      const SHAPE_SIZES = {
        default: { width: 160, height: 50 },
      };
      const MIN_SHAPE_SIZE = { width: 40, height: 30 };
      const TEXT_SIZES = {
        default: { width: 150, height: 40 },
      };
      const FONT_SIZES = {
        small: 12,
        medium: 16,
        large: 20,
      };
      const LINE_STROKES = {
        [EcoLineType.Strong]: 4,
        [EcoLineType.Normal]: 2,
        [EcoLineType.Weak]: 2,
        [EcoLineType.Stressful]: 2,
      };
      const GRID_SIZE = 20;

      // オフホワイトの色を定義
      const OFF_WHITE_COLOR = '#f9f9f9';

      // --- i18n ---
      const locales = {
        ja: {
          name: '日本語',
          headerTitle: 'Easy Ecomap JP',
          save: '保存',
          loadJSON: '読込',
          undo: '元に戻す',
          redo: 'やり直す',
          toggleGrid: 'グリッド',
          language: '言語',
          select: '選択',
          text: 'テキスト',
          addItem: '項目を追加',
          eraser: '消しゴム',
          strongConnection: '強い・肯定的',
          normalConnection: '普通',
          weakConnection: '希薄・疎遠',
          stressfulConnection: 'ストレス・葛藤',
          fontSize: '文字サイズ',
          fontSmall: '小',
          fontMedium: '中',
          fontLarge: '大',
          enterName: '名称を入力してください:',
          defaultItemName: '',
          defaultText: 'テキストを入力',
          loading: '読み込み中...',
          errorLoadingFile: 'ファイルの読み込みに失敗しました。有効なエコマップJSONファイルを選択してください。',
          saveOptions: '保存オプション',
          fileFormat: 'ファイル形式',
          padding: '余白 (px)',
          transparentBackground: '背景を透過する',
          cancel: 'キャンセル',
          confirmSave: '保存する',
          errorSavingPng: 'PNGの保存に失敗しました。画像変換中にエラーが発生しました。',
          saveDialogTitle: '保存オプション',
          fileName: 'ファイル名',
          errorSavingJson: 'JSONの保存に失敗しました。',
          fileLoadedSuccessfully: 'ファイルの読み込みが完了しました。'
        },
        en: {
          name: 'English',
          headerTitle: 'Easy Ecomap JP',
          save: 'Save',
          loadJSON: 'Load',
          undo: 'Undo',
          redo: 'Redo',
          toggleGrid: 'Grid',
          language: 'Language',
          select: 'Select',
          text: 'Text',
          addItem: 'Add Item',
          eraser: 'Eraser',
          strongConnection: 'Strong/Positive',
          normalConnection: 'Normal',
          weakConnection: 'Weak/Distant',
          stressfulConnection: 'Stressful/Conflict',
          fontSize: 'Font Size',
          fontSmall: 'Small',
          fontMedium: 'Medium',
          fontLarge: 'Large',
          enterName: 'Enter name:',
          defaultItemName: '',
          defaultText: 'Enter text',
          loading: 'Loading...',
          errorLoadingFile: 'Failed to load file. Please select a valid Ecomap JSON file.',
          saveOptions: 'Save Options',
          fileFormat: 'File Format',
          padding: 'Padding (px)',
          transparentBackground: 'Transparent Background',
          cancel: 'Cancel',
          confirmSave: 'Save',
          errorSavingPng: 'Failed to save PNG. There was an error converting the image.',
          saveDialogTitle: 'Save Options',
          fileName: 'File Name',
          errorSavingJson: 'Failed to save JSON.',
          fileLoadedSuccessfully: 'File loaded successfully.'
        },
      };

      // --- CONTEXT ---
      const LanguageContext = createContext();

      const LanguageProvider = ({ children }) => {
        const [language, setLanguage] = useState('ja');
        const t = (key) => locales[language][key] || locales.en[key];
        return React.createElement(LanguageContext.Provider, { value: { language, setLanguage, t } }, children);
      };

      const useLanguage = () => useContext(LanguageContext);

      // --- ICONS ---
      const e = React.createElement;
      const SelectIcon = ({ className = '' }) => e('svg', { className, viewBox: '0 0 24 24', fill: 'none', stroke: 'currentColor', strokeWidth: 2, strokeLinecap: 'round', strokeLinejoin: 'round' }, e('path', { d: 'M3 3l7.07 16.97 2.51-7.39 7.39-2.51L3 3z' }), e('path', { d: 'M13 13l6 6' }));
      const TextIcon = ({ className = '' }) => e('svg', { className, viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: 2, strokeLinecap: "round", strokeLinejoin: "round" }, e('path', { d: "M7 20l5-16 5 16" }), e('path', { d: "M8 14h8" }));
      const ItemIcon = ({ className = '' }) => e('svg', { className, viewBox: '0 0 24 24', fill: 'none', stroke: 'currentColor', strokeWidth: 2, strokeLinecap: 'round', strokeLinejoin: 'round' }, e('rect', { x: 3, y: 8, width: 18, height: 8, rx: 2 }));
      const EraserIcon = ({ className = '' }) => e('svg', { className, viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: 2, strokeLinecap: "round", strokeLinejoin: "round" }, e('path', { d: "m7 21-4.3-4.3c-1-1-1-2.5 0-3.4l9.6-9.6c1-1 2.5-1 3.4 0l5.6 5.6c1 1 1 2.5 0 3.4L13 21" }), e('path', { d: "M22 21H7" }), e('path', { d: "m5 12 5 5" }));
      const StrongLineIcon = ({ className = '' }) => e('svg', { className, viewBox: '0 0 24 24', fill: 'none', stroke: 'currentColor' }, e('line', { x1: 2, y1: 12, x2: 22, y2: 12, strokeWidth: 4 }));
      const NormalLineIcon = ({ className = '' }) => e('svg', { className, viewBox: '0 0 24 24', fill: 'none', stroke: 'currentColor' }, e('line', { x1: 2, y1: 12, x2: 22, y2: 12, strokeWidth: 2 }));
      const WeakLineIcon = ({ className = '' }) => e('svg', { className, viewBox: '0 0 24 24', fill: 'none', stroke: 'currentColor' }, e('line', { x1: 2, y1: 12, x2: 22, y2: 12, strokeWidth: 2, strokeDasharray: '4 4' }));
      const StressfulLineIcon = ({ className = '' }) => e('svg', { className, viewBox: '0 0 24 24', fill: 'none', stroke: 'currentColor', strokeWidth: 2, strokeLinecap: 'round', strokeLinejoin: 'round' }, e('path', { d: 'M2 12l4 4l4-8l4 8l4-4l4 4' }));
      const UndoIcon = ({ className = '' }) => e('svg', { className, viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: 2, strokeLinecap: "round", strokeLinejoin: "round" }, e('path', { d: "M3 7v6h6" }), e('path', { d: "M21 17a9 9 0 0 0-9-9 9 9 0 0 0-6 2.3L3 13" }));
      const RedoIcon = ({ className = '' }) => e('svg', { className, viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: 2, strokeLinecap: "round", strokeLinejoin: "round" }, e('path', { d: "M21 7v6h-6" }), e('path', { d: "M3 17a9 9 0 0 1 9-9 9 9 0 0 1 6 2.3L21 13" }));


      // --- COMPONENTS ---
      const ShapeComponent = ({ shape, isSelected, onDoubleClick, isEditing, onTextChange, activeTool }) => {
        const { id, x, y, width, height, text, fontSize } = shape;
        const strokeColor = 'black';
        const strokeWidth = isSelected ? 3 : 2;
        const shapeTextareaRef = useRef(null);

        let cursorClass = 'cursor-pointer';
        if (Object.values(EcoLineType).includes(activeTool)) {
          cursorClass = 'cursor-crosshair';
        }

        useEffect(() => {
          if (isEditing && shapeTextareaRef.current) {
            shapeTextareaRef.current.focus();
            shapeTextareaRef.current.select();
          }
        }, [isEditing]);

        const handleTextareaKeyDown = (evt) => {
          if (evt.key === 'Enter' && !evt.shiftKey && !evt.altKey && !evt.metaKey) {
            evt.preventDefault();
            onTextChange(id, evt.target.value, true);
          }
        };

        const textStyle = {
          fontFamily: 'inherit',
          fontSize: `${fontSize || FONT_SIZES.medium}px`,
          fontWeight: 'bold',
          textAlign: 'center',
          color: 'black',
          background: 'none',
          border: 'none',
          outline: 'none',
          resize: 'none',
          width: '100%',
          height: '100%',
          display: 'flex',
          alignItems: 'center',
          justifyContent: 'center',
          padding: '4px',
          margin: '0',
          boxSizing: 'border-box',
          whiteSpace: 'pre-wrap',
          wordBreak: 'break-word',
        };

        return e('g', {
          transform: `translate(${x}, ${y})`,
          className: cursorClass,
          onDoubleClick: () => !isEditing && onDoubleClick(id),
        },
          e('rect', {
            width, height, rx: 15, ry: 15,
            fill: OFF_WHITE_COLOR, stroke: strokeColor, strokeWidth
          }),
          isEditing ?
            e('foreignObject', { x: 0, y: 0, width: width, height: height },
              e('textarea', {
                ref: shapeTextareaRef,
                value: text,
                onChange: (evt) => onTextChange(id, evt.target.value),
                onBlur: (evt) => onTextChange(id, evt.target.value, true),
                onKeyDown: handleTextareaKeyDown,
                style: textStyle
              })
            )
            :
            e('foreignObject', { x: 0, y: 0, width, height, className: 'select-none' },
              e('div', { style: textStyle }, text)
            )
        );
      };

      const Palette = ({ activeTool, setActiveTool, fontSize, setFontSize }) => {
        const { t } = useLanguage();

        const ToolButton = ({ label, caption, tool, activeTool, onSelect, children }) => e('button', {
          onClick: () => onSelect(tool),
          className: `flex flex-col items-center justify-center min-w-[3.5rem] h-12 px-3 rounded-lg gap-1 transition-all duration-200 border ${activeTool === tool
            ? 'bg-blue-500 text-white border-blue-500 shadow-lg transform scale-105'
            : 'bg-white text-gray-600 hover:bg-gray-50 border-gray-200 hover:border-gray-300 hover:shadow-md'
            }`,
          title: label
        },
          children,
          e('span', { className: 'text-xs font-medium truncate' }, caption)
        );

        const getShortLabel = (key, fallback) => {
          const shortLabels = {
            ja: {
              select: '選択',
              text: 'テキスト',
              addItem: '項目',
              eraser: '消去',
              strongConnection: '強い',
              normalConnection: '普通',
              weakConnection: '希薄',
              stressfulConnection: 'ストレス'
            },
            en: {
              select: 'Select',
              text: 'Text',
              addItem: 'Item',
              eraser: 'Erase',
              strongConnection: 'Strong',
              normalConnection: 'Normal',
              weakConnection: 'Weak',
              stressfulConnection: 'Stress'
            }
          };
          return shortLabels[useLanguage().language]?.[key] || fallback;
        };

        const allTools = [
          { id: 'select', icon: e(SelectIcon), label: t('select'), shortLabel: getShortLabel('select', t('select')) },
          { id: 'text', icon: e(TextIcon), label: t('text'), shortLabel: getShortLabel('text', t('text')) },
          { id: 'shape', icon: e(ItemIcon), label: t('addItem'), shortLabel: getShortLabel('addItem', t('addItem')) },
          { id: 'eraser', icon: e(EraserIcon), label: t('eraser'), shortLabel: getShortLabel('eraser', t('eraser')) },
          { id: EcoLineType.Strong, icon: e(StrongLineIcon), label: t('strongConnection'), shortLabel: getShortLabel('strongConnection', t('strongConnection')) },
          { id: EcoLineType.Normal, icon: e(NormalLineIcon), label: t('normalConnection'), shortLabel: getShortLabel('normalConnection', t('normalConnection')) },
          { id: EcoLineType.Weak, icon: e(WeakLineIcon), label: t('weakConnection'), shortLabel: getShortLabel('weakConnection', t('weakConnection')) },
          { id: EcoLineType.Stressful, icon: e(StressfulLineIcon), label: t('stressfulConnection'), shortLabel: getShortLabel('stressfulConnection', t('stressfulConnection')) }
        ];

        return e('div', { className: 'bg-gradient-to-r from-gray-50 to-white border-b border-gray-200 shadow-sm px-4 py-3 overflow-x-auto' },
          e('div', { className: 'flex items-center gap-6 flex-nowrap' },
            // 基本ツール
            e('div', { className: 'flex items-center gap-2' },
              e('div', { className: 'text-xs font-semibold text-gray-500 uppercase tracking-wide mb-1' }, '基本ツール'),
              e('div', { className: 'flex items-center gap-1' },
                e(ToolButton, {
                  label: t('select'),
                  caption: getShortLabel('select', t('select')),
                  tool: 'select',
                  activeTool,
                  onSelect: setActiveTool
                }, e(SelectIcon, { className: 'w-4 h-4' })),
                e(ToolButton, {
                  label: t('text'),
                  caption: getShortLabel('text', t('text')),
                  tool: 'text',
                  activeTool,
                  onSelect: setActiveTool
                }, e(TextIcon, { className: 'w-4 h-4' })),
                e(ToolButton, {
                  label: t('addItem'),
                  caption: getShortLabel('addItem', t('addItem')),
                  tool: 'shape',
                  activeTool,
                  onSelect: setActiveTool
                }, e(ItemIcon, { className: 'w-4 h-4' })),
                e(ToolButton, {
                  label: t('eraser'),
                  caption: getShortLabel('eraser', t('eraser')),
                  tool: 'eraser',
                  activeTool,
                  onSelect: setActiveTool
                }, e(EraserIcon, { className: 'w-4 h-4' }))
              )
            ),
            // 関係線
            e('div', { className: 'flex items-center gap-2' },
              e('div', { className: 'text-xs font-semibold text-gray-500 uppercase tracking-wide mb-1' }, '関係線'),
              e('div', { className: 'flex items-center gap-1' },
                e(ToolButton, {
                  label: t('strongConnection'),
                  caption: getShortLabel('strongConnection', t('strongConnection')),
                  tool: EcoLineType.Strong,
                  activeTool,
                  onSelect: setActiveTool
                }, e(StrongLineIcon, { className: 'w-4 h-4' })),
                e(ToolButton, {
                  label: t('normalConnection'),
                  caption: getShortLabel('normalConnection', t('normalConnection')),
                  tool: EcoLineType.Normal,
                  activeTool,
                  onSelect: setActiveTool
                }, e(NormalLineIcon, { className: 'w-4 h-4' })),
                e(ToolButton, {
                  label: t('weakConnection'),
                  caption: getShortLabel('weakConnection', t('weakConnection')),
                  tool: EcoLineType.Weak,
                  activeTool,
                  onSelect: setActiveTool
                }, e(WeakLineIcon, { className: 'w-4 h-4' })),
                e(ToolButton, {
                  label: t('stressfulConnection'),
                  caption: getShortLabel('stressfulConnection', t('stressfulConnection')),
                  tool: EcoLineType.Stressful,
                  activeTool,
                  onSelect: setActiveTool
                }, e(StressfulLineIcon, { className: 'w-4 h-4' }))
              )
            ),
            // セパレーター
            e('div', { className: 'w-px h-8 bg-gray-300' }),
            // 設定
            e('div', { className: 'flex items-center gap-4' },
              e('div', { className: 'flex items-center gap-2 bg-white rounded-lg px-3 py-2 border border-gray-200 shadow-sm' },
                e('span', { className: 'text-sm font-medium text-gray-700' }, '字'),
                e('select', {
                  value: fontSize,
                  onChange: (e) => setFontSize(Number(e.target.value)),
                  className: 'w-16 h-8 px-2 text-sm border border-gray-200 rounded-md bg-white text-gray-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent transition-all duration-200'
                },
                  Object.entries(FONT_SIZES).map(([name, size]) =>
                    e('option', { key: name, value: size }, t(`font${name.charAt(0).toUpperCase() + name.slice(1)}`))
                  )
                )
              )
            )
          )
        );
      };

      const Header = ({ onSave, onLoadJSON, onUndo, onRedo, canUndo, canRedo, showGrid, setShowGrid }) => {
        const { t, language, setLanguage } = useLanguage();
        const fileInputRef = useRef(null);

        const Button = ({ onClick, children, className = '', disabled = false, title = '' }) => e('button', {
          onClick, disabled, title,
          className: `px-4 py-2 text-sm font-medium text-gray-700 bg-white border border-gray-200 rounded-lg hover:bg-gray-50 hover:border-gray-300 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent disabled:bg-gray-100 disabled:cursor-not-allowed disabled:text-gray-400 whitespace-nowrap transition-all duration-200 shadow-sm hover:shadow-md ${className}`
        }, children);

        const IconButton = ({ onClick, children, disabled = false, title = '', active = false }) => e('button', {
          onClick, disabled, title,
          className: `p-2 border border-gray-200 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent disabled:opacity-50 disabled:cursor-not-allowed transition-all duration-200 ${active
            ? 'bg-blue-50 text-blue-600 border-blue-300 shadow-sm'
            : 'bg-white text-gray-600 hover:bg-gray-50 hover:border-gray-300 shadow-sm hover:shadow-md'
            }`
        }, children);

        return e('header', { className: 'bg-gradient-to-r from-gray-50 to-white border-b border-gray-200 shadow-lg z-20 w-full' },
          e('div', { className: 'max-w-full mx-auto px-4 overflow-x-auto' },
            e('div', { className: 'flex justify-between items-center h-16 flex-nowrap' },
              e('div', { className: 'flex items-center gap-4' },
                e('h1', { className: 'text-xl font-bold text-gray-800 whitespace-nowrap' }, t('headerTitle')),
                e('a', {
                  href: '/manual.html',
                  target: '_blank',
                  rel: 'noopener noreferrer',
                  className: 'text-sm text-blue-600 hover:text-blue-800 hover:underline font-medium'
                }, '📖 マニュアル')
              ),
              e('div', { className: 'flex items-center gap-3 flex-nowrap' },
                e(Button, { onClick: onSave }, t('save')),
                e(Button, { onClick: () => fileInputRef.current?.click() }, t('loadJSON')),
                e('input', { type: 'file', ref: fileInputRef, onChange: onLoadJSON, accept: '.json', className: 'hidden' }),
                e('div', { className: 'flex items-center gap-1' },
                  e(IconButton, { onClick: onUndo, disabled: !canUndo, title: t('undo') }, e(UndoIcon, { className: 'w-4 h-4' })),
                  e(IconButton, { onClick: onRedo, disabled: !canRedo, title: t('redo') }, e(RedoIcon, { className: 'w-4 h-4' }))
                ),
                e('div', { className: 'flex items-center whitespace-nowrap ml-2 bg-white rounded-lg px-3 py-2 border border-gray-200 shadow-sm' },
                  e('input', {
                    type: 'checkbox',
                    id: 'grid-toggle',
                    checked: showGrid,
                    onChange: (e) => setShowGrid(e.target.checked),
                    className: 'mr-2 rounded border-gray-300 text-blue-600 focus:ring-blue-500'
                  }),
                  e('label', { htmlFor: 'grid-toggle', className: 'text-sm text-gray-700 whitespace-nowrap font-medium' }, t('toggleGrid'))
                ),
                e('select', {
                  value: language,
                  onChange: (e) => setLanguage(e.target.value),
                  className: 'px-3 py-2 border border-gray-200 rounded-lg bg-white text-gray-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent whitespace-nowrap shadow-sm hover:shadow-md transition-all duration-200'
                },
                  Object.keys(locales).map(lang => e('option', { key: lang, value: lang }, locales[lang].name))
                )
              )
            )
          )
        );
      };

      const Canvas = ({ canvasState, onMouseDown, onMouseMove, onMouseUp, onMouseLeave, onDoubleClickShape, onDoubleClickText, editingTextId, onTextChange, editingShapeId, onShapeTextChange, selectedElementIds, drawingLine, selectionBox, showGrid, svgRef, activeTool, shapePreview }) => {
        const { shapes, lines, texts, width, height } = canvasState;
        const textareaRef = useRef(null);

        useEffect(() => {
          if (editingTextId && textareaRef.current) {
            textareaRef.current.focus();
            textareaRef.current.select();
          }
        }, [editingTextId]);

        let cursorClass = 'cursor-default';
        if (drawingLine || Object.values(EcoLineType).includes(activeTool) || activeTool === 'shape' || activeTool === 'text') {
          cursorClass = 'cursor-crosshair';
        } else if (activeTool === 'eraser') {
          cursorClass = 'cursor-pointer';
        }

        const generateZigzagPath = (start, end) => {
          const dx = end.x - start.x, dy = end.y - start.y;
          const distance = Math.sqrt(dx * dx + dy * dy);
          const segments = Math.max(2, Math.floor(distance / 15));
          const amplitude = 8;
          let path = `M ${start.x} ${start.y} `;
          for (let i = 1; i < segments; i++) {
            const t = i / segments;
            const x = start.x + dx * t;
            const y = start.y + dy * t;
            const perpDx = -dy / distance, perpDy = dx / distance;
            const offsetX = perpDx * amplitude * (i % 2 === 0 ? 1 : -1);
            const offsetY = perpDy * amplitude * (i % 2 === 0 ? 1 : -1);
            path += `L ${x + offsetX} ${y + offsetY} `;
          }
          path += `L ${end.x} ${end.y}`;
          return path;
        };

        const getResizeHandles = (element) => {
          if (!element) return [];
          const { x, y, width, height } = element;
          const handleSize = 8;
          const h2 = handleSize / 2;

          return [
            { id: 'top-left', x: x - h2, y: y - h2, cursor: 'cursor-nwse-resize' },
            { id: 'top', x: x + width / 2 - h2, y: y - h2, cursor: 'cursor-ns-resize' },
            { id: 'top-right', x: x + width - h2, y: y - h2, cursor: 'cursor-nesw-resize' },
            { id: 'left', x: x - h2, y: y + height / 2 - h2, cursor: 'cursor-ew-resize' },
            { id: 'right', x: x + width - h2, y: y + height / 2 - h2, cursor: 'cursor-ew-resize' },
            { id: 'bottom-left', x: x - h2, y: y + height - h2, cursor: 'cursor-nwse-resize' },
            { id: 'bottom', x: x + width / 2 - h2, y: y + height - h2, cursor: 'cursor-ns-resize' },
            { id: 'bottom-right', x: x + width - h2, y: y + height - h2, cursor: 'cursor-nwse-resize' },
          ];
        };

        const singleSelectedElement = selectedElementIds.length === 1 ? [...shapes, ...texts].find(s => s.id === selectedElementIds[0]) : null;
        const singleSelectedLine = selectedElementIds.length === 1 ? lines.find(l => l.id === selectedElementIds[0]) : null;

        return e('svg', { ref: svgRef, className: `w-full h-full ${cursorClass}`, width, height, onMouseDown, onMouseMove, onMouseUp, onMouseLeave },
          e('defs', null,
            showGrid && e('pattern', { id: 'grid', width: GRID_SIZE, height: GRID_SIZE, patternUnits: 'userSpaceOnUse' },
              e('path', { d: `M ${GRID_SIZE} 0 L 0 0 0 ${GRID_SIZE}`, fill: 'none', stroke: 'rgba(0, 0, 0, 0.15)', strokeWidth: '1' })
            )
          ),
          e('rect', { width: '100%', height: '100%', fill: showGrid ? 'url(#grid)' : OFF_WHITE_COLOR }),
          shapePreview && e('rect', {
            x: shapePreview.x, y: shapePreview.y, width: shapePreview.width, height: shapePreview.height,
            rx: 15, ry: 15,
            fill: OFF_WHITE_COLOR, stroke: 'rgba(0,0,0,0.4)', strokeWidth: 2, strokeDasharray: '5,5'
          }),
          // 完成した線を描画（選択状態の太さ変更あり）
          lines.map(line => {
            const isSelected = selectedElementIds.includes(line.id);
            const strokeWidth = LINE_STROKES[line.type] + (isSelected ? 2 : 0);
            const strokeColor = 'black';
            let lineCursorClass = activeTool === 'eraser' ? 'cursor-pointer' : '';
            if (Object.values(EcoLineType).includes(activeTool)) {
              lineCursorClass = 'cursor-crosshair';
            }

            if (line.type === EcoLineType.Stressful) {
              return e('path', { key: line.id, d: generateZigzagPath(line.start, line.end), stroke: strokeColor, strokeWidth, fill: 'none', className: lineCursorClass });
            }
            return e('line', { key: line.id, x1: line.start.x, y1: line.start.y, x2: line.end.x, y2: line.end.y, stroke: strokeColor, strokeWidth, strokeDasharray: line.type === EcoLineType.Weak ? '5,5' : 'none', className: lineCursorClass });
          }),
          // 描画中の線を描画（選択状態の太さ変更なし）
          drawingLine && (() => {
            const strokeWidth = LINE_STROKES[drawingLine.type];
            const strokeColor = 'black';

            if (drawingLine.type === EcoLineType.Stressful) {
              return e('path', { key: 'drawing-line', d: generateZigzagPath(drawingLine.start, drawingLine.end), stroke: strokeColor, strokeWidth, fill: 'none' });
            }
            return e('line', { key: 'drawing-line', x1: drawingLine.start.x, y1: drawingLine.start.y, x2: drawingLine.end.x, y2: drawingLine.end.y, stroke: strokeColor, strokeWidth, strokeDasharray: drawingLine.type === EcoLineType.Weak ? '5,5' : 'none' });
          })(),
          shapes.map(shape => e(ShapeComponent, { key: shape.id, shape, isSelected: selectedElementIds.includes(shape.id), onDoubleClick: onDoubleClickShape, isEditing: editingShapeId === shape.id, onTextChange: onShapeTextChange, activeTool })),
          texts.map(text => {
            const isSelected = selectedElementIds.includes(text.id);
            const isEditing = editingTextId === text.id;
            let elementCursorClass = 'cursor-pointer';
            if (activeTool === 'eraser') {
              elementCursorClass = 'cursor-pointer';
            } else if (Object.values(EcoLineType).includes(activeTool)) {
              elementCursorClass = 'cursor-crosshair';
            }

            return e('g', { key: text.id, transform: `translate(${text.x}, ${text.y})`, className: elementCursorClass },
              isEditing ? e('foreignObject', { x: 0, y: 0, width: text.width, height: text.height },
                e('textarea', {
                  ref: textareaRef, value: text.text,
                  onChange: (e) => onTextChange(text.id, e.target.value),
                  onBlur: () => onTextChange(text.id, text.text, true),
                  onKeyDown: (evt) => { if (evt.key === 'Enter' && !evt.shiftKey && !evt.altKey && !evt.metaKey) { evt.preventDefault(); onTextChange(text.id, text.text, true); } },
                  style: { fontSize: `${text.fontSize}px` },
                  className: "w-full h-full p-1 border border-blue-500 rounded-md resize-none bg-gray-50 text-black"
                })
              ) : e('foreignObject', { x: 0, y: 0, width: text.width, height: text.height, onDoubleClick: () => onDoubleClickText(text.id) },
                e('div', {
                  style: { fontSize: `${text.fontSize}px`, border: isSelected ? '2px solid black' : '1px solid transparent', padding: isSelected ? '0px' : '1px' },
                  className: "w-full h-full p-1 box-border break-words text-black"
                }, text.text)
              )
            );
          }),
          selectionBox && e('rect', { x: selectionBox.x, y: selectionBox.y, width: selectionBox.width, height: selectionBox.height, fill: 'rgba(59, 130, 246, 0.2)', stroke: 'rgba(59, 130, 246, 0.8)', strokeWidth: '1' }),
          singleSelectedElement && getResizeHandles(singleSelectedElement).map(handle => e('rect', {
            key: handle.id, 'data-handle': handle.id, x: handle.x, y: handle.y, width: 8, height: 8,
            className: `resize-handle ${handle.cursor}`
          })),
          singleSelectedLine && [
            e('circle', { key: 'line-start-handle', 'data-line-handle': 'start', cx: singleSelectedLine.start.x, cy: singleSelectedLine.start.y, r: 6, className: 'line-handle cursor-move' }),
            e('circle', { key: 'line-end-handle', 'data-line-handle': 'end', cx: singleSelectedLine.end.x, cy: singleSelectedLine.end.y, r: 6, className: 'line-handle cursor-move' })
          ],
          drawingLine && e('circle', { cx: drawingLine.start.x, cy: drawingLine.start.y, r: 6, className: 'line-start-point' })
        );
      };

      const ToolHint = ({ activeTool, drawingLine, t }) => {
        const { language } = useLanguage();

        const getToolHint = (tool, isDrawing) => {
          const hints = {
            ja: {
              select: 'クリックで選択、ドラッグで移動、選択後の四隅をドラッグでサイズ変更',
              text: 'クリックでテキストを配置、既存テキストをダブルクリックで編集',
              shape: 'クリックで項目を配置、既存項目をダブルクリックで名前を編集',
              eraser: '削除したいオブジェクトや線をクリック',
              Strong: isDrawing ? 'マウスを離して線を完成 (Escapeでキャンセル)' : 'ドラッグして線を描画（開始点から終了点まで）',
              Normal: isDrawing ? 'マウスを離して線を完成 (Escapeでキャンセル)' : 'ドラッグして線を描画（開始点から終了点まで）',
              Weak: isDrawing ? 'マウスを離して線を完成 (Escapeでキャンセル)' : 'ドラッグして線を描画（開始点から終了点まで）',
              Stressful: isDrawing ? 'マウスを離して線を完成 (Escapeでキャンセル)' : 'ドラッグして線を描画（開始点から終了点まで）'
            },
            en: {
              select: 'Click to select, drag to move, drag corners after selection to resize',
              text: 'Click to place text, double-click existing text to edit',
              shape: 'Click to place item, double-click existing item to edit name',
              eraser: 'Click objects or lines to delete',
              Strong: isDrawing ? 'Release mouse to complete line (Escape to cancel)' : 'Drag to draw line (from start point to end point)',
              Normal: isDrawing ? 'Release mouse to complete line (Escape to cancel)' : 'Drag to draw line (from start point to end point)',
              Weak: isDrawing ? 'Release mouse to complete line (Escape to cancel)' : 'Drag to draw line (from start point to end point)',
              Stressful: isDrawing ? 'Release mouse to complete line (Escape to cancel)' : 'Drag to draw line (from start point to end point)'
            }
          };
          return hints[language]?.[tool] || hints.en[tool];
        };

        return e('div', { className: 'absolute bottom-16 left-1/2 transform -translate-x-1/2 bg-black bg-opacity-75 text-white px-4 py-2 rounded-lg text-sm max-w-2xl text-center z-10 whitespace-nowrap' },
          getToolHint(activeTool, !!drawingLine)
        );
      };

      const Footer = () => {
        const { t, language } = useLanguage();
        return e('footer', { className: 'bg-white border-t border-gray-200 p-4 mx-4 mb-4 rounded-t-xl shadow-lg' },
          e('div', { className: 'max-w-7xl mx-auto' },
            e('div', { className: 'flex justify-between items-center text-sm text-gray-500' },
              e('span', null, '© 2025 Easy Ecomap JP by soi24.com. All rights reserved.'),
              e('div', { className: 'flex space-x-6' },
                e('a', {
                  href: `/privacy.html${language === 'en' ? '?lang=en' : ''}`,
                  target: '_blank',
                  rel: 'noopener noreferrer',
                  className: 'text-gray-500 hover:text-gray-700 hover:underline transition-colors'
                }, language === 'ja' ? 'プライバシーポリシー' : 'Privacy Policy'),
                e('a', {
                  href: `/terms.html${language === 'en' ? '?lang=en' : ''}`,
                  target: '_blank',
                  rel: 'noopener noreferrer',
                  className: 'text-gray-500 hover:text-gray-700 hover:underline transition-colors'
                }, language === 'ja' ? '利用規約' : 'Terms of Service'),
                e('a', {
                  href: `/faq.html${language === 'en' ? '?lang=en' : ''}`,
                  target: '_blank',
                  rel: 'noopener noreferrer',
                  className: 'text-gray-500 hover:text-gray-700 hover:underline transition-colors'
                }, language === 'ja' ? 'よくある質問' : 'FAQ')
              )
            )
          )
        );
      };

      const SaveDialog = ({ isOpen, onClose, onSave, t }) => {
        const [fileFormat, setFileFormat] = useState('json');
        const [fileName, setFileName] = useState('ecomap');
        const [padding, setPadding] = useState(20);
        const [transparentBackground, setTransparentBackground] = useState(false);

        const handleSave = () => {
          const extension = fileFormat === 'png' ? '.png' : '.json';
          const fullFileName = fileName.endsWith(extension) ? fileName : fileName + extension;
          onSave(fullFileName, fileFormat, { padding, transparentBackground });
          onClose();
        };

        if (!isOpen) return null;

        return e('div', { className: 'fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50' },
          e('div', { className: 'bg-white rounded-xl shadow-2xl p-6 w-96 max-w-[90vw] border border-gray-200' },
            e('h2', { className: 'text-lg font-semibold text-gray-900 mb-4' }, t('saveDialogTitle')),
            e('div', { className: 'space-y-4' },
              e('div', null,
                e('label', { className: 'block text-sm font-medium text-gray-700 mb-2' }, t('fileName')),
                e('input', {
                  type: 'text',
                  value: fileName,
                  onChange: (e) => setFileName(e.target.value),
                  className: 'w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500',
                  placeholder: 'ecomap'
                })
              ),
              e('div', null,
                e('label', { className: 'block text-sm font-medium text-gray-700 mb-2' }, t('fileFormat')),
                e('select', {
                  value: fileFormat,
                  onChange: (e) => setFileFormat(e.target.value),
                  className: 'w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500'
                },
                  e('option', { value: 'json' }, 'JSON (推奨)'),
                  e('option', { value: 'png' }, 'PNG')
                )
              ),
              fileFormat === 'png' && e('div', null,
                e('label', { className: 'block text-sm font-medium text-gray-700 mb-2' }, t('padding')),
                e('input', {
                  type: 'number',
                  value: padding,
                  onChange: (e) => setPadding(parseInt(e.target.value) || 0),
                  className: 'w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500',
                  min: '0'
                })
              ),
              fileFormat === 'png' && e('label', { className: 'flex items-center space-x-2' },
                e('input', {
                  type: 'checkbox',
                  checked: transparentBackground,
                  onChange: (e) => setTransparentBackground(e.target.checked),
                  className: 'h-4 w-4 text-blue-600 rounded'
                }),
                e('span', { className: 'text-sm text-gray-700' }, t('transparentBackground'))
              ),
              fileFormat === 'json' && e('div', { className: 'text-sm text-gray-600 bg-blue-50 p-3 rounded-md' }, 'JSON形式は後から編集可能で、データの完全性が保たれます。'),
              e('div', { className: 'flex justify-end gap-3 pt-4' },
                e('button', {
                  onClick: onClose,
                  className: 'px-4 py-2 text-sm font-medium text-gray-700 bg-white border border-gray-200 rounded-lg hover:bg-gray-50 hover:border-gray-300 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent transition-all duration-200 shadow-sm hover:shadow-md'
                }, t('cancel')),
                e('button', {
                  onClick: handleSave,
                  className: 'px-4 py-2 text-sm font-medium text-white bg-blue-600 border border-blue-600 rounded-lg hover:bg-blue-700 hover:border-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent transition-all duration-200 shadow-sm hover:shadow-md'
                }, t('save'))
              )
            )
          )
        );
      };

      // --- MAIN APP ---
      const App = () => {
        const { t } = useLanguage();
        const [canvasState, setCanvasState] = useState({ shapes: [], lines: [], texts: [], width: 1200, height: 800 });
        const [history, setHistory] = useState([{ shapes: [], lines: [], texts: [], width: 1200, height: 800 }]);
        const [historyIndex, setHistoryIndex] = useState(0);
        const [activeTool, setActiveTool] = useState('select');
        const [fontSize, setFontSize] = useState(FONT_SIZES.medium);
        const [selectedElementIds, setSelectedElementIds] = useState([]);
        const [editingShapeId, setEditingShapeId] = useState(null);
        const [editingTextId, setEditingTextId] = useState(null);
        const [showGrid, setShowGrid] = useState(true);
        const [drawingLine, setDrawingLine] = useState(null);
        const isDrawingLineRef = useRef(false);
        const [selectionBox, setSelectionBox] = useState(null);
        const [shapePreview, setShapePreview] = useState(null);
        const [resizingState, setResizingState] = useState(null);
        const [lineEditingState, setLineEditingState] = useState(null);
        const [saveDialogOpen, setSaveDialogOpen] = useState(false);
        const [isLoading, setIsLoading] = useState(false);
        const svgRef = useRef();
        const isDraggingRef = useRef(false);
        const dragStartPosRef = useRef(null);
        const selectedElementsStartPosRef = useRef([]);

        const getSVGPoint = useCallback((clientX, clientY) => {
          if (!svgRef.current) return { x: 0, y: 0 };

          const pt = svgRef.current.createSVGPoint();
          pt.x = clientX;
          pt.y = clientY;
          const ctm = svgRef.current.getScreenCTM();
          if (ctm) {
            return pt.matrixTransform(ctm.inverse());
          }

          // Fallback if getScreenCTM fails
          const rect = svgRef.current.getBoundingClientRect();
          return {
            x: clientX - rect.left,
            y: clientY - rect.top
          };
        }, []);

        const createState = useCallback((state, newState) => ({ ...state, ...newState }), []);

        const updateHistory = useCallback((newState) => {
          const newHistory = history.slice(0, historyIndex + 1);
          newHistory.push(newState);
          setHistory(newHistory);
          setHistoryIndex(newHistory.length - 1);
          setCanvasState(newState);
        }, [history, historyIndex]);

        const undo = useCallback(() => {
          if (historyIndex > 0) {
            const newIndex = historyIndex - 1;
            setHistoryIndex(newIndex);
            setCanvasState(history[newIndex]);
            setSelectedElementIds([]);
            setEditingShapeId(null);
            setEditingTextId(null);
          }
        }, [history, historyIndex]);

        const redo = useCallback(() => {
          if (historyIndex < history.length - 1) {
            const newIndex = historyIndex + 1;
            setHistoryIndex(newIndex);
            setCanvasState(history[newIndex]);
            setSelectedElementIds([]);
            setEditingShapeId(null);
            setEditingTextId(null);
          }
        }, [history, historyIndex]);

        const findElementAt = useCallback((point) => {
          const { shapes, lines, texts } = canvasState;
          for (let text of texts) {
            if (point.x >= text.x && point.x <= text.x + text.width && point.y >= text.y && point.y <= text.y + text.height) {
              return { type: 'text', element: text };
            }
          }
          for (let shape of shapes) {
            if (point.x >= shape.x && point.x <= shape.x + shape.width && point.y >= shape.y && point.y <= shape.y + shape.height) {
              return { type: 'shape', element: shape };
            }
          }
          for (let line of lines) {
            const dist = distanceToLine(point, line.start, line.end);
            if (dist < 10) {
              return { type: 'line', element: line };
            }
          }
          return null;
        }, [canvasState]);

        const findShapeAt = useCallback((point) => {
          return canvasState.shapes.find(shape =>
            point.x >= shape.x &&
            point.x <= shape.x + shape.width &&
            point.y >= shape.y &&
            point.y <= shape.y + shape.height
          );
        }, [canvasState]);

        const distanceToLine = (point, lineStart, lineEnd) => {
          const A = point.x - lineStart.x;
          const B = point.y - lineStart.y;
          const C = lineEnd.x - lineStart.x;
          const D = lineEnd.y - lineStart.y;

          const dot = A * C + B * D;
          const lenSq = C * C + D * D;
          let param = -1;
          if (lenSq !== 0) param = dot / lenSq;

          let xx, yy;
          if (param < 0) {
            xx = lineStart.x;
            yy = lineStart.y;
          } else if (param > 1) {
            xx = lineEnd.x;
            yy = lineEnd.y;
          } else {
            xx = lineStart.x + param * C;
            yy = lineStart.y + param * D;
          }

          const dx = point.x - xx;
          const dy = point.y - yy;
          return Math.sqrt(dx * dx + dy * dy);
        };

        // Auto-snap function for line endpoints to shape centers
        const findSnapTarget = useCallback((point, threshold = 20) => {
          const { shapes } = canvasState;
          for (let shape of shapes) {
            const centerX = shape.x + shape.width / 2;
            const centerY = shape.y + shape.height / 2;
            const distance = Math.sqrt((point.x - centerX) ** 2 + (point.y - centerY) ** 2);

            if (distance <= threshold) {
              return {
                point: { x: centerX, y: centerY },
                shapeId: shape.id
              };
            }
          }
          return null;
        }, [canvasState]);

        const createUniqueId = () => `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;

        const addShape = useCallback((position) => {
          const id = createUniqueId();
          const newShape = {
            id, type: EcoShapeType.Item, x: position.x - SHAPE_SIZES.default.width / 2, y: position.y - SHAPE_SIZES.default.height / 2,
            width: SHAPE_SIZES.default.width, height: SHAPE_SIZES.default.height, text: t('defaultItemName'), fontSize: FONT_SIZES.medium
          };
          updateHistory(createState(canvasState, { shapes: [...canvasState.shapes, newShape] }));
        }, [canvasState, updateHistory, createState, t]);

        const addText = useCallback((position) => {
          const id = createUniqueId();
          const newText = {
            id, x: position.x - TEXT_SIZES.default.width / 2, y: position.y - TEXT_SIZES.default.height / 2,
            width: TEXT_SIZES.default.width, height: TEXT_SIZES.default.height, text: t('defaultText'), fontSize
          };
          updateHistory(createState(canvasState, { texts: [...canvasState.texts, newText] }));
        }, [canvasState, updateHistory, createState, fontSize, t]);

        const addLine = useCallback((start, end, type, startShapeId = null, endShapeId = null) => {
          const id = createUniqueId();
          const newLine = { id, start, end, type, startShapeId, endShapeId };
          updateHistory(createState(canvasState, { lines: [...canvasState.lines, newLine] }));
        }, [canvasState, updateHistory, createState]);

        const deleteElement = useCallback((elementId) => {
          const newShapes = canvasState.shapes.filter(s => s.id !== elementId);
          const newLines = canvasState.lines.filter(l =>
            l.id !== elementId && l.startShapeId !== elementId && l.endShapeId !== elementId
          );
          const newTexts = canvasState.texts.filter(t => t.id !== elementId);
          updateHistory(createState(canvasState, { shapes: newShapes, lines: newLines, texts: newTexts }));
          setSelectedElementIds([]);
        }, [canvasState, updateHistory, createState]);

        const moveElements = useCallback((elementIds, deltaX, deltaY) => {
          const newShapes = canvasState.shapes.map(shape => {
            if (!elementIds.includes(shape.id)) return shape;
            const startPos = selectedElementsStartPosRef.current.find(e => e.id === shape.id)?.startPos;
            return startPos ? { ...shape, x: startPos.x + deltaX, y: startPos.y + deltaY } : shape;
          });
          const newTexts = canvasState.texts.map(text => {
            if (!elementIds.includes(text.id)) return text;
            const startPos = selectedElementsStartPosRef.current.find(e => e.id === text.id)?.startPos;
            return startPos ? { ...text, x: startPos.x + deltaX, y: startPos.y + deltaY } : text;
          });
          const newLines = canvasState.lines.map(line => {
            // Skip line updates if currently editing this line
            if (lineEditingState && lineEditingState.lineId === line.id) {
              return line;
            }

            // Direct line movement
            if (elementIds.includes(line.id)) {
              const startPos = selectedElementsStartPosRef.current.find(e => e.id === line.id)?.startPos;
              if (!startPos) return line;
              const lineWidth = line.end.x - line.start.x;
              const lineHeight = line.end.y - line.start.y;
              return {
                ...line,
                start: { x: startPos.x + deltaX, y: startPos.y + deltaY },
                end: { x: startPos.x + deltaX + lineWidth, y: startPos.y + deltaY + lineHeight }
              };
            }

            // Line following connected shapes
            const startShape = newShapes.find(s => s.id === line.startShapeId);
            const endShape = newShapes.find(s => s.id === line.endShapeId);

            return {
              ...line,
              start: startShape ?
                { x: startShape.x + startShape.width / 2, y: startShape.y + startShape.height / 2 } :
                line.start,
              end: endShape ?
                { x: endShape.x + endShape.width / 2, y: endShape.y + endShape.height / 2 } :
                line.end
            };
          });
          setCanvasState(createState(canvasState, { shapes: newShapes, lines: newLines, texts: newTexts }));
        }, [canvasState, createState, lineEditingState]);

        const handleMouseDown = useCallback((evt) => {
          evt.preventDefault();
          const point = getSVGPoint(evt.clientX, evt.clientY);

          // Check for resize handle click
          const handleId = evt.target.dataset.handle;
          if (handleId && selectedElementIds.length === 1) {
            const element = [...canvasState.shapes, ...canvasState.texts].find(e => e.id === selectedElementIds[0]);
            if (element) {
              setResizingState({
                elementId: element.id,
                handle: handleId,
                startX: element.x,
                startY: element.y,
                startWidth: element.width,
                startHeight: element.height,
                startMouseX: point.x,
                startMouseY: point.y
              });
              return;
            }
          }

          // Check for line handle click
          const lineHandleType = evt.target.dataset.lineHandle;
          if (lineHandleType && selectedElementIds.length === 1) {
            const line = canvasState.lines.find(l => l.id === selectedElementIds[0]);
            if (line) {
              // Temporarily disconnect the line from shapes during editing
              const tempLine = { ...line };
              if (lineHandleType === 'start') {
                tempLine.startShapeId = null;
              } else if (lineHandleType === 'end') {
                tempLine.endShapeId = null;
              }

              const newLines = canvasState.lines.map(l => l.id === line.id ? tempLine : l);
              setCanvasState(createState(canvasState, { lines: newLines }));

              setLineEditingState({
                lineId: line.id,
                handle: lineHandleType,
                originalLine: { ...line }
              });
              return;
            }
          }

          if (activeTool === 'select') {
            const elementAtPoint = findElementAt(point);
            if (elementAtPoint) {
              let elementsToMove = selectedElementIds;
              if (!selectedElementIds.includes(elementAtPoint.element.id)) {
                elementsToMove = [elementAtPoint.element.id];
                setSelectedElementIds(elementsToMove);
              }
              isDraggingRef.current = true;
              dragStartPosRef.current = point;
              selectedElementsStartPosRef.current = elementsToMove.map(id => {
                const el = [...canvasState.shapes, ...canvasState.texts, ...canvasState.lines].find(e => e.id === id);
                return el ? { id, startPos: el.x !== undefined ? { x: el.x, y: el.y } : { x: el.start.x, y: el.start.y } } : null;
              }).filter(Boolean);
            } else {
              setSelectedElementIds([]);
              setSelectionBox({ x: point.x, y: point.y, width: 0, height: 0 });
            }
          } else if (activeTool === 'text') {
            addText(point);
          } else if (activeTool === 'shape') {
            addShape(point);
          } else if (activeTool === 'eraser') {
            const elementAtPoint = findElementAt(point);
            if (elementAtPoint) {
              deleteElement(elementAtPoint.element.id);
            }
          } else if (Object.values(EcoLineType).includes(activeTool)) {
            // Start drag-style line drawing with auto-snap
            const snapTarget = findSnapTarget(point);
            const startPoint = snapTarget ? snapTarget.point : point;
            isDrawingLineRef.current = true;
            setDrawingLine({ start: startPoint, end: startPoint, type: activeTool, startShapeId: snapTarget?.shapeId });
          }
        }, [activeTool, getSVGPoint, findElementAt, findShapeAt, selectedElementIds, addText, addShape, deleteElement, canvasState, addLine, findSnapTarget]);

        const handleMouseMove = useCallback((evt) => {
          const point = getSVGPoint(evt.clientX, evt.clientY);

          if (resizingState) {
            // Handle resizing
            const { elementId, handle, startX, startY, startWidth, startHeight, startMouseX, startMouseY } = resizingState;
            const deltaX = point.x - startMouseX;
            const deltaY = point.y - startMouseY;

            let newX = startX, newY = startY, newWidth = startWidth, newHeight = startHeight;

            if (handle.includes('left')) {
              newX = startX + deltaX;
              newWidth = startWidth - deltaX;
            }
            if (handle.includes('right')) {
              newWidth = startWidth + deltaX;
            }
            if (handle.includes('top')) {
              newY = startY + deltaY;
              newHeight = startHeight - deltaY;
            }
            if (handle.includes('bottom')) {
              newHeight = startHeight + deltaY;
            }

            // Apply minimum size constraints
            newWidth = Math.max(newWidth, MIN_SHAPE_SIZE.width);
            newHeight = Math.max(newHeight, MIN_SHAPE_SIZE.height);

            // Update element
            const newShapes = canvasState.shapes.map(shape =>
              shape.id === elementId ? { ...shape, x: newX, y: newY, width: newWidth, height: newHeight } : shape
            );
            const newTexts = canvasState.texts.map(text =>
              text.id === elementId ? { ...text, x: newX, y: newY, width: newWidth, height: newHeight } : text
            );
            setCanvasState(createState(canvasState, { shapes: newShapes, texts: newTexts }));
          } else if (lineEditingState) {
            // Handle line editing
            const { lineId, handle, originalLine } = lineEditingState;
            const snapTarget = findSnapTarget(point);
            const targetPoint = snapTarget ? snapTarget.point : point;

            const newLines = canvasState.lines.map(line => {
              if (line.id !== lineId) return line;

              if (handle === 'start') {
                return {
                  ...line,
                  start: targetPoint,
                  startShapeId: snapTarget?.shapeId || null
                };
              } else if (handle === 'end') {
                return {
                  ...line,
                  end: targetPoint,
                  endShapeId: snapTarget?.shapeId || null
                };
              }
              return line;
            });

            setCanvasState(createState(canvasState, { lines: newLines }));
          } else if (isDrawingLineRef.current && drawingLine) {
            // Update line end point in real-time while dragging with auto-snap
            const snapTarget = findSnapTarget(point);
            const endPoint = snapTarget ? snapTarget.point : point;
            setDrawingLine(prev => ({ ...prev, end: endPoint }));
          } else if (selectionBox) {
            const startX = Math.min(selectionBox.x, point.x);
            const startY = Math.min(selectionBox.y, point.y);
            const width = Math.abs(point.x - selectionBox.x);
            const height = Math.abs(point.y - selectionBox.y);
            setSelectionBox({ x: startX, y: startY, width, height });
          } else if (isDraggingRef.current && dragStartPosRef.current && selectedElementIds.length > 0) {
            const deltaX = point.x - dragStartPosRef.current.x;
            const deltaY = point.y - dragStartPosRef.current.y;
            moveElements(selectedElementIds, deltaX, deltaY);
          } else if (activeTool === 'shape' && isDraggingRef.current) {
            const startX = Math.min(dragStartPosRef.current.x, point.x);
            const startY = Math.min(dragStartPosRef.current.y, point.y);
            const width = Math.abs(point.x - dragStartPosRef.current.x);
            const height = Math.abs(point.y - dragStartPosRef.current.y);
            setShapePreview({ x: startX, y: startY, width: Math.max(width, MIN_SHAPE_SIZE.width), height: Math.max(height, MIN_SHAPE_SIZE.height) });
          }
        }, [getSVGPoint, drawingLine, selectionBox, selectedElementIds, moveElements, activeTool, resizingState, canvasState, createState]);

        const handleMouseUp = useCallback((evt) => {
          if (isDrawingLineRef.current && drawingLine) {
            // Complete the line drawing with auto-snap
            const point = getSVGPoint(evt.clientX, evt.clientY);
            const snapTarget = findSnapTarget(point);
            const endPoint = snapTarget ? snapTarget.point : point;
            addLine(drawingLine.start, endPoint, drawingLine.type, drawingLine.startShapeId, snapTarget?.shapeId);
            setDrawingLine(null);
            isDrawingLineRef.current = false;
          } else if (selectionBox) {
            const selectedIds = [...canvasState.shapes, ...canvasState.texts].filter(element => {
              const elementRight = element.x + element.width;
              const elementBottom = element.y + element.height;
              const boxRight = selectionBox.x + selectionBox.width;
              const boxBottom = selectionBox.y + selectionBox.height;

              return element.x < boxRight && elementRight > selectionBox.x && element.y < boxBottom && elementBottom > selectionBox.y;
            }).map(el => el.id);
            setSelectedElementIds(selectedIds);
            setSelectionBox(null);
          } else if (isDraggingRef.current && selectedElementIds.length > 0) {
            updateHistory(canvasState);
          } else if (lineEditingState) {
            // Complete line editing
            updateHistory(canvasState);
            setLineEditingState(null);
          } else if (shapePreview) {
            const id = createUniqueId();
            const newShape = {
              id, type: EcoShapeType.Item,
              ...shapePreview,
              text: t('defaultItemName'),
              fontSize: FONT_SIZES.medium
            };
            updateHistory(createState(canvasState, { shapes: [...canvasState.shapes, newShape] }));
            setShapePreview(null);
          }

          isDraggingRef.current = false;
          dragStartPosRef.current = null;
          selectedElementsStartPosRef.current = [];

          // Reset resize state
          if (resizingState) {
            updateHistory(canvasState);
            setResizingState(null);
          }
        }, [selectionBox, canvasState, selectedElementIds, updateHistory, shapePreview, createState, t, isDrawingLineRef, drawingLine, getSVGPoint, findShapeAt, addLine, resizingState, lineEditingState, findSnapTarget]);

        const handleMouseLeave = useCallback(() => {
          setSelectionBox(null);
          setShapePreview(null);
          // Cancel line drawing if mouse leaves canvas
          if (isDrawingLineRef.current) {
            setDrawingLine(null);
            isDrawingLineRef.current = false;
          }
          // Cancel line editing if mouse leaves canvas
          if (lineEditingState) {
            setLineEditingState(null);
          }
          isDraggingRef.current = false;
          dragStartPosRef.current = null;
          selectedElementsStartPosRef.current = [];
        }, [lineEditingState]);


        const handleDoubleClickShape = useCallback((shapeId) => {
          setEditingShapeId(shapeId);
          setSelectedElementIds([]);
        }, []);

        const handleDoubleClickText = useCallback((textId) => {
          setEditingTextId(textId);
          setSelectedElementIds([]);
        }, []);

        const handleShapeTextChange = useCallback((shapeId, newText, shouldFinish = false) => {
          const newShapes = canvasState.shapes.map(shape =>
            shape.id === shapeId ? { ...shape, text: newText } : shape
          );
          setCanvasState(createState(canvasState, { shapes: newShapes }));

          if (shouldFinish) {
            updateHistory(createState(canvasState, { shapes: newShapes }));
            setEditingShapeId(null);
          }
        }, [canvasState, createState, updateHistory]);

        const handleTextChange = useCallback((textId, newText, shouldFinish = false) => {
          const newTexts = canvasState.texts.map(text =>
            text.id === textId ? { ...text, text: newText } : text
          );
          setCanvasState(createState(canvasState, { texts: newTexts }));

          if (shouldFinish) {
            updateHistory(createState(canvasState, { texts: newTexts }));
            setEditingTextId(null);
          }
        }, [canvasState, createState, updateHistory]);

        const handleSave = useCallback(async (fileName, format, options = {}) => {
          setSaveDialogOpen(false);

          if (format === 'json') {
            try {
              // JSON形式で保存（データの完全性を保持）
              const saveData = {
                version: '1.0',
                timestamp: new Date().toISOString(),
                canvasState,
                grid: showGrid,
                canvasSize: {
                  width: canvasState.width,
                  height: canvasState.height
                }
              };

              const jsonString = JSON.stringify(saveData, null, 2);
              const blob = new Blob([jsonString], { type: 'application/json' });
              const url = URL.createObjectURL(blob);
              const link = document.createElement('a');
              link.href = url;
              link.download = fileName;
              link.click();
              URL.revokeObjectURL(url);
            } catch (error) {
              console.error('Error saving JSON:', error);
              alert(t('errorSavingJson'));
            }
          } else if (format === 'png') {
            try {
              console.log('Starting PNG export...');
              const svgElement = svgRef.current;
              if (!svgElement) {
                console.error('SVG element not found');
                return;
              }

              // オブジェクトがある範囲を計算
              const calculateContentBounds = () => {
                let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;

                // シェイプの範囲を計算
                canvasState.shapes.forEach(shape => {
                  minX = Math.min(minX, shape.x);
                  minY = Math.min(minY, shape.y);
                  maxX = Math.max(maxX, shape.x + shape.width);
                  maxY = Math.max(maxY, shape.y + shape.height);
                });

                // テキストの範囲を計算
                canvasState.texts.forEach(text => {
                  minX = Math.min(minX, text.x);
                  minY = Math.min(minY, text.y);
                  maxX = Math.max(maxX, text.x + text.width);
                  maxY = Math.max(maxY, text.y + text.height);
                });

                // 線の範囲を計算
                canvasState.lines.forEach(line => {
                  minX = Math.min(minX, line.start.x, line.end.x);
                  minY = Math.min(minY, line.start.y, line.end.y);
                  maxX = Math.max(maxX, line.start.x, line.end.x);
                  maxY = Math.max(maxY, line.start.y, line.end.y);
                });

                // オブジェクトが存在しない場合はデフォルトサイズを使用
                if (minX === Infinity) {
                  return { x: 0, y: 0, width: 1200, height: 800 };
                }

                return { x: minX, y: minY, width: maxX - minX, height: maxY - minY };
              };

              const contentBounds = calculateContentBounds();
              const padding = options.padding || 20;

              // キャンバスサイズを設定（オブジェクトの範囲 + パディング）
              const canvasWidth = contentBounds.width + padding * 2;
              const canvasHeight = contentBounds.height + padding * 2;

              console.log('Content bounds:', contentBounds);
              console.log('Canvas size:', canvasWidth, 'x', canvasHeight);
              console.log('Padding:', padding);

              // キャンバスを作成
              const canvas = document.createElement('canvas');
              const ctx = canvas.getContext('2d');

              canvas.width = canvasWidth;
              canvas.height = canvasHeight;

              console.log('Canvas size:', canvas.width, 'x', canvas.height);

              // 背景を設定
              if (!options.transparentBackground) {
                ctx.fillStyle = 'white';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
              }

              // 新しいSVGを作成（オブジェクトの範囲に合わせて調整）
              const createOptimizedSVG = () => {
                const svgNS = 'http://www.w3.org/2000/svg';
                const newSvg = document.createElementNS(svgNS, 'svg');

                // SVGの属性を設定
                newSvg.setAttribute('width', canvasWidth);
                newSvg.setAttribute('height', canvasHeight);
                newSvg.setAttribute('viewBox', `0 0 ${canvasWidth} ${canvasHeight}`);
                newSvg.setAttribute('xmlns', svgNS);

                // 背景（グリッドなし）
                if (!options.transparentBackground) {
                  const bgRect = document.createElementNS(svgNS, 'rect');
                  bgRect.setAttribute('width', '100%');
                  bgRect.setAttribute('height', '100%');
                  bgRect.setAttribute('fill', 'white');
                  newSvg.appendChild(bgRect);
                }

                // シェイプを描画
                canvasState.shapes.forEach(shape => {
                  const rect = document.createElementNS(svgNS, 'rect');
                  const adjustedX = shape.x - contentBounds.x + padding;
                  const adjustedY = shape.y - contentBounds.y + padding;

                  rect.setAttribute('x', adjustedX);
                  rect.setAttribute('y', adjustedY);
                  rect.setAttribute('width', shape.width);
                  rect.setAttribute('height', shape.height);
                  rect.setAttribute('rx', '15');
                  rect.setAttribute('ry', '15');
                  rect.setAttribute('fill', OFF_WHITE_COLOR);
                  rect.setAttribute('stroke', 'black');
                  rect.setAttribute('stroke-width', '2');

                  newSvg.appendChild(rect);

                  // テキストを描画
                  if (shape.text) {
                    const text = document.createElementNS(svgNS, 'text');
                    text.setAttribute('x', adjustedX + shape.width / 2);
                    text.setAttribute('y', adjustedY + shape.height / 2);
                    text.setAttribute('text-anchor', 'middle');
                    text.setAttribute('dominant-baseline', 'middle');
                    text.setAttribute('font-size', shape.fontSize || FONT_SIZES.medium);
                    text.setAttribute('font-weight', 'bold');
                    text.setAttribute('fill', 'black');
                    text.textContent = shape.text;
                    newSvg.appendChild(text);
                  }
                });

                // テキスト要素を描画
                canvasState.texts.forEach(text => {
                  const textElement = document.createElementNS(svgNS, 'text');
                  const adjustedX = text.x - contentBounds.x + padding;
                  const adjustedY = text.y - contentBounds.y + padding;

                  textElement.setAttribute('x', adjustedX);
                  textElement.setAttribute('y', adjustedY + text.height / 2);
                  textElement.setAttribute('font-size', text.fontSize);
                  textElement.setAttribute('fill', 'black');
                  textElement.setAttribute('dominant-baseline', 'middle');
                  textElement.textContent = text.text;
                  newSvg.appendChild(textElement);
                });

                // 線を描画
                canvasState.lines.forEach(line => {
                  const adjustedStartX = line.start.x - contentBounds.x + padding;
                  const adjustedStartY = line.start.y - contentBounds.y + padding;
                  const adjustedEndX = line.end.x - contentBounds.x + padding;
                  const adjustedEndY = line.end.y - contentBounds.y + padding;

                  if (line.type === EcoLineType.Stressful) {
                    // ジグザグ線の描画
                    const path = document.createElementNS(svgNS, 'path');
                    const dx = adjustedEndX - adjustedStartX;
                    const dy = adjustedEndY - adjustedStartY;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    const segments = Math.max(2, Math.floor(distance / 15));
                    const amplitude = 8;

                    let pathData = `M ${adjustedStartX} ${adjustedStartY} `;
                    for (let i = 1; i < segments; i++) {
                      const t = i / segments;
                      const x = adjustedStartX + dx * t;
                      const y = adjustedStartY + dy * t;
                      const perpDx = -dy / distance;
                      const perpDy = dx / distance;
                      const offsetX = perpDx * amplitude * (i % 2 === 0 ? 1 : -1);
                      const offsetY = perpDy * amplitude * (i % 2 === 0 ? 1 : -1);
                      pathData += `L ${x + offsetX} ${y + offsetY} `;
                    }
                    pathData += `L ${adjustedEndX} ${adjustedEndY}`;

                    path.setAttribute('d', pathData);
                    path.setAttribute('stroke', 'black');
                    path.setAttribute('stroke-width', LINE_STROKES[line.type]);
                    path.setAttribute('fill', 'none');
                    newSvg.appendChild(path);
                  } else {
                    // 通常の線の描画
                    const lineElement = document.createElementNS(svgNS, 'line');
                    lineElement.setAttribute('x1', adjustedStartX);
                    lineElement.setAttribute('y1', adjustedStartY);
                    lineElement.setAttribute('x2', adjustedEndX);
                    lineElement.setAttribute('y2', adjustedEndY);
                    lineElement.setAttribute('stroke', 'black');
                    lineElement.setAttribute('stroke-width', LINE_STROKES[line.type]);
                    if (line.type === EcoLineType.Weak) {
                      lineElement.setAttribute('stroke-dasharray', '5,5');
                    }
                    newSvg.appendChild(lineElement);
                  }
                });

                return newSvg;
              };

              // 最適化されたSVGを作成
              const optimizedSvg = createOptimizedSVG();

              // currentColorを実際の色に置き換え
              const replaceCurrentColor = (element) => {
                const elements = element.querySelectorAll ? element.querySelectorAll('*') : [];
                elements.forEach(el => {
                  if (el.getAttribute('stroke') === 'currentColor') {
                    el.setAttribute('stroke', 'black');
                  }
                  if (el.getAttribute('fill') === 'currentColor') {
                    el.setAttribute('fill', 'black');
                  }
                });

                // 自身の属性もチェック
                if (element.getAttribute && element.getAttribute('stroke') === 'currentColor') {
                  element.setAttribute('stroke', 'black');
                }
                if (element.getAttribute && element.getAttribute('fill') === 'currentColor') {
                  element.setAttribute('fill', 'black');
                }
              };

              replaceCurrentColor(optimizedSvg);

              const svgData = new XMLSerializer().serializeToString(optimizedSvg);
              const svgDataUrl = 'data:image/svg+xml;charset=utf-8,' + encodeURIComponent(svgData);

              // 画像として読み込み
              const img = new Image();

              img.onload = () => {
                try {
                  // 画像をキャンバスに描画（余白を考慮）
                  ctx.drawImage(img, 0, 0, canvasWidth, canvasHeight);

                  // PNGとして保存
                  canvas.toBlob(blob => {
                    if (blob) {
                      const downloadUrl = URL.createObjectURL(blob);
                      const link = document.createElement('a');
                      link.href = downloadUrl;
                      link.download = fileName;
                      document.body.appendChild(link);
                      link.click();
                      document.body.removeChild(link);
                      URL.revokeObjectURL(downloadUrl);
                      console.log('PNG export successful');
                    } else {
                      throw new Error('Failed to create PNG blob');
                    }
                  }, 'image/png', 1.0);

                } catch (error) {
                  console.error('Error in PNG conversion:', error);
                  alert(t('errorSavingPng'));
                }
              };

              img.onerror = (error) => {
                console.error('Failed to load SVG as image:', error);
                alert(t('errorSavingPng'));
              };

              img.src = svgDataUrl;

            } catch (error) {
              console.error('Error saving PNG:', error);
              alert(t('errorSavingPng'));
            }
          }
        }, [canvasState, showGrid, t]);

        const handleLoadJSON = useCallback((evt) => {
          const file = evt.target.files[0];
          if (!file) return;

          setIsLoading(true);
          const reader = new FileReader();
          reader.onload = (e) => {
            try {
              const jsonContent = e.target.result;
              const saveData = JSON.parse(jsonContent);

              // バージョンチェック
              if (!saveData.version || !saveData.canvasState) {
                throw new Error('Invalid JSON file format');
              }

              // キャンバス状態を復元
              const newCanvasState = createState(canvasState, saveData.canvasState);

              // グリッド設定を復元
              if (saveData.grid !== undefined) {
                setShowGrid(saveData.grid);
              }

              // 履歴を更新
              updateHistory(newCanvasState);
              setSelectedElementIds([]);
              setEditingShapeId(null);
              setEditingTextId(null);
              setIsLoading(false);

              // 成功メッセージ
              alert(t('fileLoadedSuccessfully'));
            } catch (error) {
              console.error('Error loading JSON:', error);
              alert(t('errorLoadingFile'));
              setIsLoading(false);
            }
          };
          reader.readAsText(file);
          evt.target.value = '';
        }, [canvasState, updateHistory, t]);

        // Keyboard shortcuts
        useEffect(() => {
          const handleKeyDown = (evt) => {
            if (evt.key === 'Escape') {
              setDrawingLine(null);
              isDrawingLineRef.current = false;
              setSelectedElementIds([]);
              setEditingShapeId(null);
              setEditingTextId(null);
            } else if (evt.key === 'Delete' || evt.key === 'Backspace') {
              if (selectedElementIds.length > 0 && !editingShapeId && !editingTextId) {
                selectedElementIds.forEach(deleteElement);
              }
            } else if ((evt.metaKey || evt.ctrlKey) && evt.key === 'z' && !evt.shiftKey) {
              evt.preventDefault();
              undo();
            } else if ((evt.metaKey || evt.ctrlKey) && (evt.key === 'y' || (evt.key === 'z' && evt.shiftKey))) {
              evt.preventDefault();
              redo();
            }
          };

          window.addEventListener('keydown', handleKeyDown);
          return () => window.removeEventListener('keydown', handleKeyDown);
        }, [selectedElementIds, editingShapeId, editingTextId, deleteElement, undo, redo]);

        // Set font size for selected texts
        useEffect(() => {
          if (selectedElementIds.length > 0) {
            const newTexts = canvasState.texts.map(text =>
              selectedElementIds.includes(text.id) ? { ...text, fontSize } : text
            );
            const newShapes = canvasState.shapes.map(shape =>
              selectedElementIds.includes(shape.id) ? { ...shape, fontSize } : shape
            );
            setCanvasState(createState(canvasState, { texts: newTexts, shapes: newShapes }));
          }
        }, [fontSize, selectedElementIds]);

        if (isLoading) {
          return e('div', { className: 'fixed inset-0 bg-white flex items-center justify-center' },
            e('div', { className: 'text-center' },
              e('div', { className: 'animate-spin rounded-full h-8 w-8 border-b-2 border-blue-600 mx-auto mb-4' }),
              e('p', { className: 'text-gray-600' }, t('loading'))
            )
          );
        }

        return e('div', { className: 'flex flex-col h-screen bg-gradient-to-br from-gray-50 to-gray-100 font-sans overflow-hidden' },
          e(Header, {
            onSave: () => setSaveDialogOpen(true),
            onLoadJSON: handleLoadJSON,
            onUndo: undo,
            onRedo: redo,
            canUndo: historyIndex > 0,
            canRedo: historyIndex < history.length - 1,
            showGrid,
            setShowGrid
          }),
          e(Palette, { activeTool, setActiveTool, fontSize, setFontSize }),
          e('main', { className: 'flex-1 overflow-auto bg-white m-4 rounded-xl shadow-lg border border-gray-200' },
            e(Canvas, {
              canvasState,
              onMouseDown: handleMouseDown,
              onMouseMove: handleMouseMove,
              onMouseUp: handleMouseUp,
              onMouseLeave: handleMouseLeave,
              onDoubleClickShape: handleDoubleClickShape,
              onDoubleClickText: handleDoubleClickText,
              editingTextId,
              onTextChange: handleTextChange,
              editingShapeId,
              onShapeTextChange: handleShapeTextChange,
              selectedElementIds,
              drawingLine,
              selectionBox,
              showGrid,
              svgRef,
              activeTool,
              shapePreview
            })
          ),
          e(ToolHint, { activeTool, drawingLine, t }),
          e(Footer),
          e(SaveDialog, {
            isOpen: saveDialogOpen,
            onClose: () => setSaveDialogOpen(false),
            onSave: handleSave,
            t
          })
        );
      };

      // Render app
      const AppWithLanguageProvider = () => e(LanguageProvider, null, e(App));
      ReactDOM.render(e(AppWithLanguageProvider), document.getElementById('root'));
    </script>
  </body>

</html>
